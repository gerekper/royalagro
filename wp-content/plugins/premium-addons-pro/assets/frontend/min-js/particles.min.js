!function () { "use strict"; "SVGPathSeg" in window || (window.SVGPathSeg = function (t, e, i) { this.pathSegType = t, this.pathSegTypeAsLetter = e, this._owningPathSegList = i }, window.SVGPathSeg.prototype.classname = "SVGPathSeg", window.SVGPathSeg.PATHSEG_UNKNOWN = 0, window.SVGPathSeg.PATHSEG_CLOSEPATH = 1, window.SVGPathSeg.PATHSEG_MOVETO_ABS = 2, window.SVGPathSeg.PATHSEG_MOVETO_REL = 3, window.SVGPathSeg.PATHSEG_LINETO_ABS = 4, window.SVGPathSeg.PATHSEG_LINETO_REL = 5, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9, window.SVGPathSeg.PATHSEG_ARC_ABS = 10, window.SVGPathSeg.PATHSEG_ARC_REL = 11, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19, window.SVGPathSeg.prototype._segmentChanged = function () { this._owningPathSegList && this._owningPathSegList.segmentChanged(this) }, window.SVGPathSegClosePath = function (t) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CLOSEPATH, "z", t) }, window.SVGPathSegClosePath.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegClosePath.prototype.toString = function () { return "[object SVGPathSegClosePath]" }, window.SVGPathSegClosePath.prototype._asPathString = function () { return this.pathSegTypeAsLetter }, window.SVGPathSegClosePath.prototype.clone = function () { return new window.SVGPathSegClosePath(void 0) }, window.SVGPathSegMovetoAbs = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_ABS, "M", t), this._x = e, this._y = i }, window.SVGPathSegMovetoAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegMovetoAbs.prototype.toString = function () { return "[object SVGPathSegMovetoAbs]" }, window.SVGPathSegMovetoAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegMovetoAbs.prototype.clone = function () { return new window.SVGPathSegMovetoAbs(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegMovetoRel = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_REL, "m", t), this._x = e, this._y = i }, window.SVGPathSegMovetoRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegMovetoRel.prototype.toString = function () { return "[object SVGPathSegMovetoRel]" }, window.SVGPathSegMovetoRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegMovetoRel.prototype.clone = function () { return new window.SVGPathSegMovetoRel(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegMovetoRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegMovetoRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoAbs = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_ABS, "L", t), this._x = e, this._y = i }, window.SVGPathSegLinetoAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoAbs.prototype.toString = function () { return "[object SVGPathSegLinetoAbs]" }, window.SVGPathSegLinetoAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegLinetoAbs.prototype.clone = function () { return new window.SVGPathSegLinetoAbs(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoRel = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_REL, "l", t), this._x = e, this._y = i }, window.SVGPathSegLinetoRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoRel.prototype.toString = function () { return "[object SVGPathSegLinetoRel]" }, window.SVGPathSegLinetoRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegLinetoRel.prototype.clone = function () { return new window.SVGPathSegLinetoRel(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegLinetoRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegLinetoRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoCubicAbs = function (t, e, i, o, n, s, a) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, "C", t), this._x = e, this._y = i, this._x1 = o, this._y1 = n, this._x2 = s, this._y2 = a }, window.SVGPathSegCurvetoCubicAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoCubicAbs.prototype.toString = function () { return "[object SVGPathSegCurvetoCubicAbs]" }, window.SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoCubicAbs.prototype.clone = function () { return new window.SVGPathSegCurvetoCubicAbs(void 0, this._x, this._y, this._x1, this._y1, this._x2, this._y2) }, Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x1", { get: function () { return this._x1 }, set: function (t) { this._x1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y1", { get: function () { return this._y1 }, set: function (t) { this._y1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x2", { get: function () { return this._x2 }, set: function (t) { this._x2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y2", { get: function () { return this._y2 }, set: function (t) { this._y2 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoCubicRel = function (t, e, i, o, n, s, a) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, "c", t), this._x = e, this._y = i, this._x1 = o, this._y1 = n, this._x2 = s, this._y2 = a }, window.SVGPathSegCurvetoCubicRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoCubicRel.prototype.toString = function () { return "[object SVGPathSegCurvetoCubicRel]" }, window.SVGPathSegCurvetoCubicRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoCubicRel.prototype.clone = function () { return new window.SVGPathSegCurvetoCubicRel(void 0, this._x, this._y, this._x1, this._y1, this._x2, this._y2) }, Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x1", { get: function () { return this._x1 }, set: function (t) { this._x1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y1", { get: function () { return this._y1 }, set: function (t) { this._y1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x2", { get: function () { return this._x2 }, set: function (t) { this._x2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y2", { get: function () { return this._y2 }, set: function (t) { this._y2 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoQuadraticAbs = function (t, e, i, o, n) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, "Q", t), this._x = e, this._y = i, this._x1 = o, this._y1 = n }, window.SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () { return "[object SVGPathSegCurvetoQuadraticAbs]" }, window.SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () { return new window.SVGPathSegCurvetoQuadraticAbs(void 0, this._x, this._y, this._x1, this._y1) }, Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "x1", { get: function () { return this._x1 }, set: function (t) { this._x1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "y1", { get: function () { return this._y1 }, set: function (t) { this._y1 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoQuadraticRel = function (t, e, i, o, n) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, "q", t), this._x = e, this._y = i, this._x1 = o, this._y1 = n }, window.SVGPathSegCurvetoQuadraticRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoQuadraticRel.prototype.toString = function () { return "[object SVGPathSegCurvetoQuadraticRel]" }, window.SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoQuadraticRel.prototype.clone = function () { return new window.SVGPathSegCurvetoQuadraticRel(void 0, this._x, this._y, this._x1, this._y1) }, Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "x1", { get: function () { return this._x1 }, set: function (t) { this._x1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "y1", { get: function () { return this._y1 }, set: function (t) { this._y1 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegArcAbs = function (t, e, i, o, n, s, a, r) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_ABS, "A", t), this._x = e, this._y = i, this._r1 = o, this._r2 = n, this._angle = s, this._largeArcFlag = a, this._sweepFlag = r }, window.SVGPathSegArcAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegArcAbs.prototype.toString = function () { return "[object SVGPathSegArcAbs]" }, window.SVGPathSegArcAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y }, window.SVGPathSegArcAbs.prototype.clone = function () { return new window.SVGPathSegArcAbs(void 0, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag) }, Object.defineProperty(window.SVGPathSegArcAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "r1", { get: function () { return this._r1 }, set: function (t) { this._r1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "r2", { get: function () { return this._r2 }, set: function (t) { this._r2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "angle", { get: function () { return this._angle }, set: function (t) { this._angle = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "largeArcFlag", { get: function () { return this._largeArcFlag }, set: function (t) { this._largeArcFlag = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcAbs.prototype, "sweepFlag", { get: function () { return this._sweepFlag }, set: function (t) { this._sweepFlag = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegArcRel = function (t, e, i, o, n, s, a, r) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_REL, "a", t), this._x = e, this._y = i, this._r1 = o, this._r2 = n, this._angle = s, this._largeArcFlag = a, this._sweepFlag = r }, window.SVGPathSegArcRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegArcRel.prototype.toString = function () { return "[object SVGPathSegArcRel]" }, window.SVGPathSegArcRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y }, window.SVGPathSegArcRel.prototype.clone = function () { return new window.SVGPathSegArcRel(void 0, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag) }, Object.defineProperty(window.SVGPathSegArcRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "r1", { get: function () { return this._r1 }, set: function (t) { this._r1 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "r2", { get: function () { return this._r2 }, set: function (t) { this._r2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "angle", { get: function () { return this._angle }, set: function (t) { this._angle = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "largeArcFlag", { get: function () { return this._largeArcFlag }, set: function (t) { this._largeArcFlag = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegArcRel.prototype, "sweepFlag", { get: function () { return this._sweepFlag }, set: function (t) { this._sweepFlag = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoHorizontalAbs = function (t, e) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, "H", t), this._x = e }, window.SVGPathSegLinetoHorizontalAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoHorizontalAbs.prototype.toString = function () { return "[object SVGPathSegLinetoHorizontalAbs]" }, window.SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x }, window.SVGPathSegLinetoHorizontalAbs.prototype.clone = function () { return new window.SVGPathSegLinetoHorizontalAbs(void 0, this._x) }, Object.defineProperty(window.SVGPathSegLinetoHorizontalAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoHorizontalRel = function (t, e) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, "h", t), this._x = e }, window.SVGPathSegLinetoHorizontalRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoHorizontalRel.prototype.toString = function () { return "[object SVGPathSegLinetoHorizontalRel]" }, window.SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x }, window.SVGPathSegLinetoHorizontalRel.prototype.clone = function () { return new window.SVGPathSegLinetoHorizontalRel(void 0, this._x) }, Object.defineProperty(window.SVGPathSegLinetoHorizontalRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoVerticalAbs = function (t, e) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, "V", t), this._y = e }, window.SVGPathSegLinetoVerticalAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoVerticalAbs.prototype.toString = function () { return "[object SVGPathSegLinetoVerticalAbs]" }, window.SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._y }, window.SVGPathSegLinetoVerticalAbs.prototype.clone = function () { return new window.SVGPathSegLinetoVerticalAbs(void 0, this._y) }, Object.defineProperty(window.SVGPathSegLinetoVerticalAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegLinetoVerticalRel = function (t, e) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, "v", t), this._y = e }, window.SVGPathSegLinetoVerticalRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegLinetoVerticalRel.prototype.toString = function () { return "[object SVGPathSegLinetoVerticalRel]" }, window.SVGPathSegLinetoVerticalRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._y }, window.SVGPathSegLinetoVerticalRel.prototype.clone = function () { return new window.SVGPathSegLinetoVerticalRel(void 0, this._y) }, Object.defineProperty(window.SVGPathSegLinetoVerticalRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoCubicSmoothAbs = function (t, e, i, o, n) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, "S", t), this._x = e, this._y = i, this._x2 = o, this._y2 = n }, window.SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () { return "[object SVGPathSegCurvetoCubicSmoothAbs]" }, window.SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () { return new window.SVGPathSegCurvetoCubicSmoothAbs(void 0, this._x, this._y, this._x2, this._y2) }, Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "x2", { get: function () { return this._x2 }, set: function (t) { this._x2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "y2", { get: function () { return this._y2 }, set: function (t) { this._y2 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoCubicSmoothRel = function (t, e, i, o, n) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, "s", t), this._x = e, this._y = i, this._x2 = o, this._y2 = n }, window.SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () { return "[object SVGPathSegCurvetoCubicSmoothRel]" }, window.SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () { return new window.SVGPathSegCurvetoCubicSmoothRel(void 0, this._x, this._y, this._x2, this._y2) }, Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "x2", { get: function () { return this._x2 }, set: function (t) { this._x2 = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "y2", { get: function () { return this._y2 }, set: function (t) { this._y2 = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoQuadraticSmoothAbs = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, "T", t), this._x = e, this._y = i }, window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () { return "[object SVGPathSegCurvetoQuadraticSmoothAbs]" }, window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () { return new window.SVGPathSegCurvetoQuadraticSmoothAbs(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathSegCurvetoQuadraticSmoothRel = function (t, e, i) { window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, "t", t), this._x = e, this._y = i }, window.SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype), window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () { return "[object SVGPathSegCurvetoQuadraticSmoothRel]" }, window.SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y }, window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () { return new window.SVGPathSegCurvetoQuadraticSmoothRel(void 0, this._x, this._y) }, Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x = t, this._segmentChanged() }, enumerable: !0 }), Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y = t, this._segmentChanged() }, enumerable: !0 }), window.SVGPathElement.prototype.createSVGPathSegClosePath = function () { return new window.SVGPathSegClosePath(void 0) }, window.SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (t, e) { return new window.SVGPathSegMovetoAbs(void 0, t, e) }, window.SVGPathElement.prototype.createSVGPathSegMovetoRel = function (t, e) { return new window.SVGPathSegMovetoRel(void 0, t, e) }, window.SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (t, e) { return new window.SVGPathSegLinetoAbs(void 0, t, e) }, window.SVGPathElement.prototype.createSVGPathSegLinetoRel = function (t, e) { return new window.SVGPathSegLinetoRel(void 0, t, e) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (t, e, i, o, n, s) { return new window.SVGPathSegCurvetoCubicAbs(void 0, t, e, i, o, n, s) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (t, e, i, o, n, s) { return new window.SVGPathSegCurvetoCubicRel(void 0, t, e, i, o, n, s) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (t, e, i, o) { return new window.SVGPathSegCurvetoQuadraticAbs(void 0, t, e, i, o) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (t, e, i, o) { return new window.SVGPathSegCurvetoQuadraticRel(void 0, t, e, i, o) }, window.SVGPathElement.prototype.createSVGPathSegArcAbs = function (t, e, i, o, n, s, a) { return new window.SVGPathSegArcAbs(void 0, t, e, i, o, n, s, a) }, window.SVGPathElement.prototype.createSVGPathSegArcRel = function (t, e, i, o, n, s, a) { return new window.SVGPathSegArcRel(void 0, t, e, i, o, n, s, a) }, window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (t) { return new window.SVGPathSegLinetoHorizontalAbs(void 0, t) }, window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (t) { return new window.SVGPathSegLinetoHorizontalRel(void 0, t) }, window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (t) { return new window.SVGPathSegLinetoVerticalAbs(void 0, t) }, window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (t) { return new window.SVGPathSegLinetoVerticalRel(void 0, t) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (t, e, i, o) { return new window.SVGPathSegCurvetoCubicSmoothAbs(void 0, t, e, i, o) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (t, e, i, o) { return new window.SVGPathSegCurvetoCubicSmoothRel(void 0, t, e, i, o) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (t, e) { return new window.SVGPathSegCurvetoQuadraticSmoothAbs(void 0, t, e) }, window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (t, e) { return new window.SVGPathSegCurvetoQuadraticSmoothRel(void 0, t, e) }, "getPathSegAtLength" in window.SVGPathElement.prototype || (window.SVGPathElement.prototype.getPathSegAtLength = function (t) { if (void 0 === t || !isFinite(t)) throw "Invalid arguments."; var e = document.createElementNS("http://www.w3.org/2000/svg", "path"); e.setAttribute("d", this.getAttribute("d")); var i = e.pathSegList.numberOfItems - 1; if (i <= 0) return 0; do { if (e.pathSegList.removeItem(i), t > e.getTotalLength()) break; i-- } while (i > 0); return i })), "SVGPathSegList" in window && "appendItem" in window.SVGPathSegList.prototype || (window.SVGPathSegList = function (t) { this._pathElement = t, this._list = this._parsePath(this._pathElement.getAttribute("d")), this._mutationObserverConfig = { attributes: !0, attributeFilter: ["d"] }, this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this)), this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig) }, window.SVGPathSegList.prototype.classname = "SVGPathSegList", Object.defineProperty(window.SVGPathSegList.prototype, "numberOfItems", { get: function () { return this._checkPathSynchronizedToList(), this._list.length }, enumerable: !0 }), Object.defineProperty(window.SVGPathElement.prototype, "pathSegList", { get: function () { return this._pathSegList || (this._pathSegList = new window.SVGPathSegList(this)), this._pathSegList }, enumerable: !0 }), Object.defineProperty(window.SVGPathElement.prototype, "normalizedPathSegList", { get: function () { return this.pathSegList }, enumerable: !0 }), Object.defineProperty(window.SVGPathElement.prototype, "animatedPathSegList", { get: function () { return this.pathSegList }, enumerable: !0 }), Object.defineProperty(window.SVGPathElement.prototype, "animatedNormalizedPathSegList", { get: function () { return this.pathSegList }, enumerable: !0 }), window.SVGPathSegList.prototype._checkPathSynchronizedToList = function () { this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords()) }, window.SVGPathSegList.prototype._updateListFromPathMutations = function (t) { if (this._pathElement) { var e = !1; t.forEach(function (t) { "d" == t.attributeName && (e = !0) }), e && (this._list = this._parsePath(this._pathElement.getAttribute("d"))) } }, window.SVGPathSegList.prototype._writeListToPath = function () { this._pathElementMutationObserver.disconnect(), this._pathElement.setAttribute("d", window.SVGPathSegList._pathSegArrayAsString(this._list)), this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig) }, window.SVGPathSegList.prototype.segmentChanged = function (t) { this._writeListToPath() }, window.SVGPathSegList.prototype.clear = function () { this._checkPathSynchronizedToList(), this._list.forEach(function (t) { t._owningPathSegList = null }), this._list = [], this._writeListToPath() }, window.SVGPathSegList.prototype.initialize = function (t) { return this._checkPathSynchronizedToList(), this._list = [t], t._owningPathSegList = this, this._writeListToPath(), t }, window.SVGPathSegList.prototype._checkValidIndex = function (t) { if (isNaN(t) || t < 0 || t >= this.numberOfItems) throw "INDEX_SIZE_ERR" }, window.SVGPathSegList.prototype.getItem = function (t) { return this._checkPathSynchronizedToList(), this._checkValidIndex(t), this._list[t] }, window.SVGPathSegList.prototype.insertItemBefore = function (t, e) { return this._checkPathSynchronizedToList(), e > this.numberOfItems && (e = this.numberOfItems), t._owningPathSegList && (t = t.clone()), this._list.splice(e, 0, t), t._owningPathSegList = this, this._writeListToPath(), t }, window.SVGPathSegList.prototype.replaceItem = function (t, e) { return this._checkPathSynchronizedToList(), t._owningPathSegList && (t = t.clone()), this._checkValidIndex(e), this._list[e] = t, t._owningPathSegList = this, this._writeListToPath(), t }, window.SVGPathSegList.prototype.removeItem = function (t) { this._checkPathSynchronizedToList(), this._checkValidIndex(t); var e = this._list[t]; return this._list.splice(t, 1), this._writeListToPath(), e }, window.SVGPathSegList.prototype.appendItem = function (t) { return this._checkPathSynchronizedToList(), t._owningPathSegList && (t = t.clone()), this._list.push(t), t._owningPathSegList = this, this._writeListToPath(), t }, window.SVGPathSegList._pathSegArrayAsString = function (t) { var e = "", i = !0; return t.forEach(function (t) { i ? (i = !1, e += t._asPathString()) : e += " " + t._asPathString() }), e }, window.SVGPathSegList.prototype._parsePath = function (t) { if (!t || 0 == t.length) return []; var e = this, i = function () { this.pathSegList = [] }; i.prototype.appendSegment = function (t) { this.pathSegList.push(t) }; var o = function (t) { this._string = t, this._currentIndex = 0, this._endIndex = this._string.length, this._previousCommand = window.SVGPathSeg.PATHSEG_UNKNOWN, this._skipOptionalSpaces() }; o.prototype._isCurrentSpace = function () { var t = this._string[this._currentIndex]; return t <= " " && (" " == t || "\n" == t || "\t" == t || "\r" == t || "\f" == t) }, o.prototype._skipOptionalSpaces = function () { for (; this._currentIndex < this._endIndex && this._isCurrentSpace();)this._currentIndex++; return this._currentIndex < this._endIndex }, o.prototype._skipOptionalSpacesOrDelimiter = function () { return !(this._currentIndex < this._endIndex && !this._isCurrentSpace() && "," != this._string.charAt(this._currentIndex)) && (this._skipOptionalSpaces() && this._currentIndex < this._endIndex && "," == this._string.charAt(this._currentIndex) && (this._currentIndex++, this._skipOptionalSpaces()), this._currentIndex < this._endIndex) }, o.prototype.hasMoreData = function () { return this._currentIndex < this._endIndex }, o.prototype.peekSegmentType = function () { var t = this._string[this._currentIndex]; return this._pathSegTypeFromChar(t) }, o.prototype._pathSegTypeFromChar = function (t) { switch (t) { case "Z": case "z": return window.SVGPathSeg.PATHSEG_CLOSEPATH; case "M": return window.SVGPathSeg.PATHSEG_MOVETO_ABS; case "m": return window.SVGPathSeg.PATHSEG_MOVETO_REL; case "L": return window.SVGPathSeg.PATHSEG_LINETO_ABS; case "l": return window.SVGPathSeg.PATHSEG_LINETO_REL; case "C": return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS; case "c": return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL; case "Q": return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS; case "q": return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL; case "A": return window.SVGPathSeg.PATHSEG_ARC_ABS; case "a": return window.SVGPathSeg.PATHSEG_ARC_REL; case "H": return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS; case "h": return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL; case "V": return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS; case "v": return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL; case "S": return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS; case "s": return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL; case "T": return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS; case "t": return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL; default: return window.SVGPathSeg.PATHSEG_UNKNOWN } }, o.prototype._nextCommandHelper = function (t, e) { return ("+" == t || "-" == t || "." == t || t >= "0" && t <= "9") && e != window.SVGPathSeg.PATHSEG_CLOSEPATH ? e == window.SVGPathSeg.PATHSEG_MOVETO_ABS ? window.SVGPathSeg.PATHSEG_LINETO_ABS : e == window.SVGPathSeg.PATHSEG_MOVETO_REL ? window.SVGPathSeg.PATHSEG_LINETO_REL : e : window.SVGPathSeg.PATHSEG_UNKNOWN }, o.prototype.initialCommandIsMoveTo = function () { if (!this.hasMoreData()) return !0; var t = this.peekSegmentType(); return t == window.SVGPathSeg.PATHSEG_MOVETO_ABS || t == window.SVGPathSeg.PATHSEG_MOVETO_REL }, o.prototype._parseNumber = function () { var t = 0, e = 0, i = 1, o = 0, n = 1, s = 1, a = this._currentIndex; if (this._skipOptionalSpaces(), this._currentIndex < this._endIndex && "+" == this._string.charAt(this._currentIndex) ? this._currentIndex++ : this._currentIndex < this._endIndex && "-" == this._string.charAt(this._currentIndex) && (this._currentIndex++, n = -1), !(this._currentIndex == this._endIndex || (this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") && "." != this._string.charAt(this._currentIndex))) { for (var r = this._currentIndex; this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9";)this._currentIndex++; if (this._currentIndex != r) for (var c = this._currentIndex - 1, l = 1; c >= r;)e += l * (this._string.charAt(c--) - "0"), l *= 10; if (this._currentIndex < this._endIndex && "." == this._string.charAt(this._currentIndex)) { if (this._currentIndex++, this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return; for (; this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9";)i *= 10, o += (this._string.charAt(this._currentIndex) - "0") / i, this._currentIndex += 1 } if (this._currentIndex != a && this._currentIndex + 1 < this._endIndex && ("e" == this._string.charAt(this._currentIndex) || "E" == this._string.charAt(this._currentIndex)) && "x" != this._string.charAt(this._currentIndex + 1) && "m" != this._string.charAt(this._currentIndex + 1)) { if (this._currentIndex++, "+" == this._string.charAt(this._currentIndex) ? this._currentIndex++ : "-" == this._string.charAt(this._currentIndex) && (this._currentIndex++, s = -1), this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return; for (; this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9";)t *= 10, t += this._string.charAt(this._currentIndex) - "0", this._currentIndex++ } var h = e + o; if (h *= n, t && (h *= Math.pow(10, s * t)), a != this._currentIndex) return this._skipOptionalSpacesOrDelimiter(), h } }, o.prototype._parseArcFlag = function () { if (!(this._currentIndex >= this._endIndex)) { var t = !1, e = this._string.charAt(this._currentIndex++); if ("0" == e) t = !1; else { if ("1" != e) return; t = !0 } return this._skipOptionalSpacesOrDelimiter(), t } }, o.prototype.parseSegment = function () { var t = this._string[this._currentIndex], i = this._pathSegTypeFromChar(t); if (i == window.SVGPathSeg.PATHSEG_UNKNOWN) { if (this._previousCommand == window.SVGPathSeg.PATHSEG_UNKNOWN) return null; if ((i = this._nextCommandHelper(t, this._previousCommand)) == window.SVGPathSeg.PATHSEG_UNKNOWN) return null } else this._currentIndex++; switch (this._previousCommand = i, i) { case window.SVGPathSeg.PATHSEG_MOVETO_REL: return new window.SVGPathSegMovetoRel(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_MOVETO_ABS: return new window.SVGPathSegMovetoAbs(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_REL: return new window.SVGPathSegLinetoRel(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_ABS: return new window.SVGPathSegLinetoAbs(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL: return new window.SVGPathSegLinetoHorizontalRel(e, this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS: return new window.SVGPathSegLinetoHorizontalAbs(e, this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL: return new window.SVGPathSegLinetoVerticalRel(e, this._parseNumber()); case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS: return new window.SVGPathSegLinetoVerticalAbs(e, this._parseNumber()); case window.SVGPathSeg.PATHSEG_CLOSEPATH: return this._skipOptionalSpaces(), new window.SVGPathSegClosePath(e); case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL: var o = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoCubicRel(e, o.x, o.y, o.x1, o.y1, o.x2, o.y2); case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS: o = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoCubicAbs(e, o.x, o.y, o.x1, o.y1, o.x2, o.y2); case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL: o = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoCubicSmoothRel(e, o.x, o.y, o.x2, o.y2); case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: o = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoCubicSmoothAbs(e, o.x, o.y, o.x2, o.y2); case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL: o = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoQuadraticRel(e, o.x, o.y, o.x1, o.y1); case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS: o = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegCurvetoQuadraticAbs(e, o.x, o.y, o.x1, o.y1); case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: return new window.SVGPathSegCurvetoQuadraticSmoothRel(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: return new window.SVGPathSegCurvetoQuadraticSmoothAbs(e, this._parseNumber(), this._parseNumber()); case window.SVGPathSeg.PATHSEG_ARC_REL: o = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegArcRel(e, o.x, o.y, o.x1, o.y1, o.arcAngle, o.arcLarge, o.arcSweep); case window.SVGPathSeg.PATHSEG_ARC_ABS: o = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() }; return new window.SVGPathSegArcAbs(e, o.x, o.y, o.x1, o.y1, o.arcAngle, o.arcLarge, o.arcSweep); default: throw "Unknown path seg type." } }; var n = new i, s = new o(t); if (!s.initialCommandIsMoveTo()) return []; for (; s.hasMoreData();) { var a = s.parseSegment(); if (!a) return []; n.appendSegment(a) } return n.pathSegList }) }(), function (t) { (function (t, e) { if ("object" == typeof exports && "object" == typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { var i = e(); for (var o in i) ("object" == typeof exports ? exports : t)[o] = i[o] } }(this, function () { return (() => { "use strict"; var t = { d: (e, i) => { for (var o in i) t.o(i, o) && !t.o(e, o) && Object.defineProperty(e, o, { enumerable: !0, get: i[o] }) }, o: (t, e) => Object.prototype.hasOwnProperty.call(t, e), r: t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) } }, e = {}; t.r(e), t.d(e, { AbsorberClickMode: () => oi, AnimationStatus: () => g, CanvasUtils: () => O, ClickMode: () => c, CollisionMode: () => d, ColorUtils: () => R, Constants: () => C, Container: () => Je, DestroyType: () => y, DivMode: () => l, DivType: () => S, EmitterClickMode: () => Si, HoverMode: () => h, InlineArrangement: () => _i, InteractivityDetect: () => b, Main: () => Hi, MoveDirection: () => n, MoveType: () => xi, OutMode: () => u, ProcessBubbleType: () => f, RotateDirection: () => s, ShapeType: () => m, SizeMode: () => p, StartValueType: () => w, ThemeMode: () => v, Type: () => Ai, Utils: () => A, Vector: () => a, pJSDom: () => Ni, particlesJS: () => Fi, tsParticles: () => Di }); class i { getSidesCount() { return 4 } draw(t, e, i) { t.rect(-i, -i, 2 * i, 2 * i) } } var o, n, s; !function (t) { t.bottom = "bottom", t.left = "left", t.right = "right", t.top = "top" }(o || (o = {})), function (t) { t.bottom = "bottom", t.bottomLeft = "bottom-left", t.bottomRight = "bottom-right", t.left = "left", t.none = "none", t.right = "right", t.top = "top", t.topLeft = "top-left", t.topRight = "top-right" }(n || (n = {})), function (t) { t.clockwise = "clockwise", t.counterClockwise = "counter-clockwise", t.random = "random" }(s || (s = {})); class a { constructor(t, e) { let i, o; if (void 0 === e) { if ("number" == typeof t) throw new Error("tsParticles - Vector not initialized correctly"); const e = t;[i, o] = [e.x, e.y] } else[i, o] = [t, e]; this.x = i, this.y = o } static clone(t) { return a.create(t.x, t.y) } static create(t, e) { return new a(t, e) } get angle() { return Math.atan2(this.y, this.x) } set angle(t) { this.updateFromAngle(t, this.length) } get length() { return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2)) } set length(t) { this.updateFromAngle(this.angle, t) } add(t) { return a.create(this.x + t.x, this.y + t.y) } addTo(t) { this.x += t.x, this.y += t.y } sub(t) { return a.create(this.x - t.x, this.y - t.y) } subFrom(t) { this.x -= t.x, this.y -= t.y } mult(t) { return a.create(this.x * t, this.y * t) } multTo(t) { this.x *= t, this.y *= t } div(t) { return a.create(this.x / t, this.y / t) } divTo(t) { this.x /= t, this.y /= t } distanceTo(t) { return this.sub(t).length } getLengthSq() { return Math.pow(this.x, 2) + Math.pow(this.y, 2) } distanceToSq(t) { return this.sub(t).getLengthSq() } manhattanDistanceTo(t) { return Math.abs(t.x - this.x) + Math.abs(t.y - this.y) } copy() { return a.clone(this) } setTo(t) { this.x = t.x, this.y = t.y } rotate(t) { return a.create(this.x * Math.cos(t) - this.y * Math.sin(t), this.x * Math.sin(t) + this.y * Math.cos(t)) } updateFromAngle(t, e) { this.x = Math.cos(t) * e, this.y = Math.sin(t) * e } } a.origin = a.create(0, 0); class r { static clamp(t, e, i) { return Math.min(Math.max(t, e), i) } static mix(t, e, i, o) { return Math.floor((t * i + e * o) / (i + o)) } static randomInRange(t) { const e = r.getRangeMax(t); let i = r.getRangeMin(t); return e === i && (i = 0), Math.random() * (e - i) + i } static getRangeValue(t) { return "number" == typeof t ? t : r.randomInRange(t) } static getRangeMin(t) { return "number" == typeof t ? t : t.min } static getRangeMax(t) { return "number" == typeof t ? t : t.max } static setRangeValue(t, e) { if (t === e || void 0 === e && "number" == typeof t) return t; const i = r.getRangeMin(t), o = r.getRangeMax(t); return void 0 !== e ? { min: Math.min(i, e), max: Math.max(o, e) } : r.setRangeValue(i, o) } static getValue(t) { const e = t.random, { enable: i, minimumValue: o } = "boolean" == typeof e ? { enable: e, minimumValue: 0 } : e; return i ? r.getRangeValue(r.setRangeValue(t.value, o)) : r.getRangeValue(t.value) } static getDistances(t, e) { const i = t.x - e.x, o = t.y - e.y; return { dx: i, dy: o, distance: Math.sqrt(i * i + o * o) } } static getDistance(t, e) { return r.getDistances(t, e).distance } static getParticleBaseVelocity(t) { const e = a.origin; switch (e.length = 1, t) { case n.top: e.angle = -Math.PI / 2; break; case n.topRight: e.angle = -Math.PI / 4; break; case n.right: e.angle = 0; break; case n.bottomRight: e.angle = Math.PI / 4; break; case n.bottom: e.angle = Math.PI / 2; break; case n.bottomLeft: e.angle = 3 * Math.PI / 4; break; case n.left: e.angle = Math.PI; break; case n.topLeft: e.angle = -3 * Math.PI / 4; break; case n.none: default: e.angle = Math.random() * Math.PI * 2 }return e } static rotateVelocity(t, e) { return { horizontal: t.horizontal * Math.cos(e) - t.vertical * Math.sin(e), vertical: t.horizontal * Math.sin(e) + t.vertical * Math.cos(e) } } static collisionVelocity(t, e, i, o) { return a.create(t.x * (i - o) / (i + o) + 2 * e.x * o / (i + o), t.y) } } var c, l, h, d, u, p, v, g, y, f, m, w, S, b, P = function (t, e, i, o) { return new (i || (i = Promise))(function (n, s) { function a(t) { try { c(o.next(t)) } catch (t) { s(t) } } function r(t) { try { c(o.throw(t)) } catch (t) { s(t) } } function c(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) { t(e) })).then(a, r) } c((o = o.apply(t, e || [])).next()) }) }; function _(t, e, i, o, n, s) { const a = { bounced: !1 }; return e.min >= o.min && e.min <= o.max && e.max >= o.min && e.max <= o.max && (t.max >= i.min && t.max <= (i.max + i.min) / 2 && n > 0 || t.min <= i.max && t.min > (i.max + i.min) / 2 && n < 0) && (a.velocity = n * -s, a.bounced = !0), a } function x(t, e) { if (e instanceof Array) { for (const i of e) if (t.matches(i)) return !0; return !1 } return t.matches(e) } class A { static isSsr() { return "undefined" == typeof window || !window } static get animate() { return A.isSsr() ? t => setTimeout(t) : t => (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.setTimeout)(t) } static get cancelAnimation() { return A.isSsr() ? t => clearTimeout(t) : t => (window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.clearTimeout)(t) } static isInArray(t, e) { return t === e || e instanceof Array && e.indexOf(t) > -1 } static loadFont(t) { return P(this, void 0, void 0, function* () { try { yield document.fonts.load(`${t.weight} 36px '${t.font}'`) } catch (t) { } }) } static arrayRandomIndex(t) { return Math.floor(Math.random() * t.length) } static itemFromArray(t, e, i = !0) { return t[void 0 !== e && i ? e % t.length : A.arrayRandomIndex(t)] } static isPointInside(t, e, i, o) { return A.areBoundsInside(A.calculateBounds(t, null != i ? i : 0), e, o) } static areBoundsInside(t, e, i) { let n = !0; return i && i !== o.bottom || (n = t.top < e.height), !n || i && i !== o.left || (n = t.right > 0), !n || i && i !== o.right || (n = t.left < e.width), !n || i && i !== o.top || (n = t.bottom > 0), n } static calculateBounds(t, e) { return { bottom: t.y + e, left: t.x - e, right: t.x + e, top: t.y - e } } static loadImage(t) { return new Promise((e, i) => { if (!t) return void i("Error tsParticles - No image.src"); const o = { source: t, type: t.substr(t.length - 3) }, n = new Image; n.addEventListener("load", () => { o.element = n, e(o) }), n.addEventListener("error", () => { i(`Error tsParticles - loading image: ${t}`) }), n.src = t }) } static downloadSvgImage(t) { return P(this, void 0, void 0, function* () { if (!t) throw new Error("Error tsParticles - No image.src"); const e = { source: t, type: t.substr(t.length - 3) }; if ("svg" !== e.type) return A.loadImage(t); const i = yield fetch(e.source); if (!i.ok) throw new Error("Error tsParticles - Image not found"); return e.svgData = yield i.text(), e }) } static deepExtend(t, ...e) { for (const i of e) { if (null == i) continue; if ("object" != typeof i) { t = i; continue } const e = Array.isArray(i); !e || "object" == typeof t && t && Array.isArray(t) ? e || "object" == typeof t && t && !Array.isArray(t) || (t = {}) : t = []; for (const e in i) { if ("__proto__" === e) continue; const o = i[e], n = "object" == typeof o, s = t; s[e] = n && Array.isArray(o) ? o.map(t => A.deepExtend(s[e], t)) : A.deepExtend(s[e], o) } } return t } static isDivModeEnabled(t, e) { return e instanceof Array ? !!e.find(e => e.enable && A.isInArray(t, e.mode)) : A.isInArray(t, e.mode) } static divModeExecute(t, e, i) { if (e instanceof Array) for (const o of e) { const e = o.mode; o.enable && A.isInArray(t, e) && A.singleDivModeExecute(o, i) } else { const o = e.mode; e.enable && A.isInArray(t, o) && A.singleDivModeExecute(e, i) } } static singleDivModeExecute(t, e) { const i = t.selectors; if (i instanceof Array) for (const o of i) e(o, t); else e(i, t) } static divMode(t, e) { if (e && t) return t instanceof Array ? t.find(t => x(e, t.selectors)) : x(e, t.selectors) ? t : void 0 } static circleBounceDataFromParticle(t) { return { position: t.getPosition(), radius: t.getRadius(), mass: t.getMass(), velocity: t.velocity, factor: { horizontal: r.getValue(t.options.bounce.horizontal), vertical: r.getValue(t.options.bounce.vertical) } } } static circleBounce(t, e) { const i = t.velocity.x, o = t.velocity.y, n = t.position, s = e.position; if (i * (s.x - n.x) + o * (s.y - n.y) >= 0) { const i = -Math.atan2(s.y - n.y, s.x - n.x), o = t.mass, a = e.mass, c = t.velocity.rotate(i), l = e.velocity.rotate(i), h = r.collisionVelocity(c, l, o, a), d = r.collisionVelocity(l, c, o, a), u = h.rotate(-i), p = d.rotate(-i); t.velocity.x = u.x * t.factor.horizontal, t.velocity.y = u.y * t.factor.vertical, e.velocity.x = p.x * e.factor.horizontal, e.velocity.y = p.y * e.factor.vertical } } static rectBounce(t, e) { const i = t.getPosition(), o = t.getRadius(), n = A.calculateBounds(i, o), s = _({ min: n.left, max: n.right }, { min: n.top, max: n.bottom }, { min: e.left, max: e.right }, { min: e.top, max: e.bottom }, t.velocity.x, r.getValue(t.options.bounce.horizontal)); s.bounced && (void 0 !== s.velocity && (t.velocity.x = s.velocity), void 0 !== s.position && (t.position.x = s.position)); const a = _({ min: n.top, max: n.bottom }, { min: n.left, max: n.right }, { min: e.top, max: e.bottom }, { min: e.left, max: e.right }, t.velocity.y, r.getValue(t.options.bounce.vertical)); a.bounced && (void 0 !== a.velocity && (t.velocity.y = a.velocity), void 0 !== a.position && (t.position.y = a.position)) } } class C { } function V(t, e, i) { let o = i; return o < 0 && (o += 1), o > 1 && (o -= 1), o < 1 / 6 ? t + 6 * (e - t) * o : o < .5 ? e : o < 2 / 3 ? t + (e - t) * (2 / 3 - o) * 6 : t } function G(t) { if (t.startsWith("rgb")) { const e = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.]+)\s*)?\)/i.exec(t); return e ? { a: e.length > 4 ? parseFloat(e[5]) : 1, b: parseInt(e[3], 10), g: parseInt(e[2], 10), r: parseInt(e[1], 10) } : void 0 } if (t.startsWith("hsl")) { const e = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i.exec(t); return e ? R.hslaToRgba({ a: e.length > 4 ? parseFloat(e[5]) : 1, h: parseInt(e[1], 10), l: parseInt(e[3], 10), s: parseInt(e[2], 10) }) : void 0 } if (t.startsWith("hsv")) { const e = /hsva?\(\s*(\d+)°\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i.exec(t); return e ? R.hsvaToRgba({ a: e.length > 4 ? parseFloat(e[5]) : 1, h: parseInt(e[1], 10), s: parseInt(e[2], 10), v: parseInt(e[3], 10) }) : void 0 } { const e = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, i = t.replace(e, (t, e, i, o, n) => e + e + i + i + o + o + (void 0 !== n ? n + n : "")), o = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(i); return o ? { a: void 0 !== o[4] ? parseInt(o[4], 16) / 255 : 1, b: parseInt(o[3], 16), g: parseInt(o[2], 16), r: parseInt(o[1], 16) } : void 0 } } C.canvasClass = "tsparticles-canvas-el", C.randomColorValue = "random", C.midColorValue = "mid", C.touchEndEvent = "touchend", C.mouseDownEvent = "mousedown", C.mouseUpEvent = "mouseup", C.mouseMoveEvent = "mousemove", C.touchStartEvent = "touchstart", C.touchMoveEvent = "touchmove", C.mouseLeaveEvent = "mouseleave", C.mouseOutEvent = "mouseout", C.touchCancelEvent = "touchcancel", C.resizeEvent = "resize", C.visibilityChangeEvent = "visibilitychange", C.noPolygonDataLoaded = "No polygon data loaded.", C.noPolygonFound = "No polygon found, you need to specify SVG url in config."; class R { static colorToRgb(t, e, i = !0) { var o, n, s; if (void 0 === t) return; const a = "string" == typeof t ? { value: t } : t; let r; if ("string" == typeof a.value) r = a.value === C.randomColorValue ? R.getRandomRgbColor() : R.stringToRgb(a.value); else if (a.value instanceof Array) { const t = A.itemFromArray(a.value, e, i); r = R.colorToRgb({ value: t }) } else { const t = a.value, e = null !== (o = t.rgb) && void 0 !== o ? o : a.value; if (void 0 !== e.r) r = e; else { const e = null !== (n = t.hsl) && void 0 !== n ? n : a.value; if (void 0 !== e.h && void 0 !== e.l) r = R.hslToRgb(e); else { const e = null !== (s = t.hsv) && void 0 !== s ? s : a.value; void 0 !== e.h && void 0 !== e.v && (r = R.hsvToRgb(e)) } } } return r } static colorToHsl(t, e, i = !0) { const o = R.colorToRgb(t, e, i); return void 0 !== o ? R.rgbToHsl(o) : void 0 } static rgbToHsl(t) { const e = t.r / 255, i = t.g / 255, o = t.b / 255, n = Math.max(e, i, o), s = Math.min(e, i, o), a = { h: 0, l: (n + s) / 2, s: 0 }; return n != s && (a.s = a.l < .5 ? (n - s) / (n + s) : (n - s) / (2 - n - s), a.h = e === n ? (i - o) / (n - s) : a.h = i === n ? 2 + (o - e) / (n - s) : 4 + (e - i) / (n - s)), a.l *= 100, a.s *= 100, a.h *= 60, a.h < 0 && (a.h += 360), a } static stringToAlpha(t) { var e; return null === (e = G(t)) || void 0 === e ? void 0 : e.a } static stringToRgb(t) { return G(t) } static hslToRgb(t) { const e = { b: 0, g: 0, r: 0 }, i = { h: t.h / 360, l: t.l / 100, s: t.s / 100 }; if (0 === i.s) e.b = i.l, e.g = i.l, e.r = i.l; else { const t = i.l < .5 ? i.l * (1 + i.s) : i.l + i.s - i.l * i.s, o = 2 * i.l - t; e.r = V(o, t, i.h + 1 / 3), e.g = V(o, t, i.h), e.b = V(o, t, i.h - 1 / 3) } return e.r = Math.floor(255 * e.r), e.g = Math.floor(255 * e.g), e.b = Math.floor(255 * e.b), e } static hslaToRgba(t) { const e = R.hslToRgb(t); return { a: t.a, b: e.b, g: e.g, r: e.r } } static hslToHsv(t) { const e = t.l / 100, i = e + t.s / 100 * Math.min(e, 1 - e), o = i ? 2 * (1 - e / i) : 0; return { h: t.h, s: 100 * o, v: 100 * i } } static hslaToHsva(t) { const e = R.hslToHsv(t); return { a: t.a, h: e.h, s: e.s, v: e.v } } static hsvToHsl(t) { const e = t.v / 100, i = e * (1 - t.s / 100 / 2), o = 0 === i || 1 === i ? 0 : (e - i) / Math.min(i, 1 - i); return { h: t.h, l: 100 * i, s: 100 * o } } static hsvaToHsla(t) { const e = R.hsvToHsl(t); return { a: t.a, h: e.h, l: e.l, s: e.s } } static hsvToRgb(t) { const e = { b: 0, g: 0, r: 0 }, i = t.h / 60, o = t.s / 100, n = t.v / 100, s = n * o, a = s * (1 - Math.abs(i % 2 - 1)); let r; if (i >= 0 && i <= 1 ? r = { r: s, g: a, b: 0 } : i > 1 && i <= 2 ? r = { r: a, g: s, b: 0 } : i > 2 && i <= 3 ? r = { r: 0, g: s, b: a } : i > 3 && i <= 4 ? r = { r: 0, g: a, b: s } : i > 4 && i <= 5 ? r = { r: a, g: 0, b: s } : i > 5 && i <= 6 && (r = { r: s, g: 0, b: a }), r) { const t = n - s; e.r = Math.floor(255 * (r.r + t)), e.g = Math.floor(255 * (r.g + t)), e.b = Math.floor(255 * (r.b + t)) } return e } static hsvaToRgba(t) { const e = R.hsvToRgb(t); return { a: t.a, b: e.b, g: e.g, r: e.r } } static rgbToHsv(t) { const e = { r: t.r / 255, g: t.g / 255, b: t.b / 255 }, i = Math.max(e.r, e.g, e.b), o = i - Math.min(e.r, e.g, e.b); let n = 0; return i === e.r ? n = (e.g - e.b) / o * 60 : i === e.g ? n = 60 * (2 + (e.b - e.r) / o) : i === e.b && (n = 60 * (4 + (e.r - e.g) / o)), { h: n, s: 100 * (i ? o / i : 0), v: 100 * i } } static rgbaToHsva(t) { const e = R.rgbToHsv(t); return { a: t.a, h: e.h, s: e.s, v: e.v } } static getRandomRgbColor(t) { const e = null != t ? t : 0; return { b: Math.floor(r.randomInRange(r.setRangeValue(e, 256))), g: Math.floor(r.randomInRange(r.setRangeValue(e, 256))), r: Math.floor(r.randomInRange(r.setRangeValue(e, 256))) } } static getStyleFromRgb(t, e) { return `rgba(${t.r}, ${t.g}, ${t.b}, ${null != e ? e : 1})` } static getStyleFromHsl(t, e) { return `hsla(${t.h}, ${t.s}%, ${t.l}%, ${null != e ? e : 1})` } static getStyleFromHsv(t, e) { return R.getStyleFromHsl(R.hsvToHsl(t), e) } static mix(t, e, i, o) { let n = t, s = e; return void 0 === n.r && (n = R.hslToRgb(t)), void 0 === s.r && (s = R.hslToRgb(e)), { b: r.mix(n.b, s.b, i, o), g: r.mix(n.g, s.g, i, o), r: r.mix(n.r, s.r, i, o) } } static replaceColorSvg(t, e, i) { if (!t.svgData) return ""; return t.svgData.replace(/#([0-9A-F]{3,6})/gi, () => R.getStyleFromHsl(e, i)) } static getLinkColor(t, e, i) { var o, n; if (i === C.randomColorValue) return R.getRandomRgbColor(); if ("mid" !== i) return i; { const i = null !== (o = t.getFillColor()) && void 0 !== o ? o : t.getStrokeColor(), s = null !== (n = null == e ? void 0 : e.getFillColor()) && void 0 !== n ? n : null == e ? void 0 : e.getStrokeColor(); if (i && s && e) return R.mix(i, s, t.getRadius(), e.getRadius()); { const t = null != i ? i : s; if (t) return R.hslToRgb(t) } } } static getLinkRandomColor(t, e, i) { const o = "string" == typeof t ? t : t.value; return o === C.randomColorValue ? i ? R.colorToRgb({ value: o }) : e ? C.randomColorValue : C.midColorValue : R.colorToRgb({ value: o }) } static getHslFromAnimation(t) { return void 0 !== t ? { h: t.h.value, s: t.s.value, l: t.l.value } : void 0 } } function T(t, e, i) { t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(i.x, i.y), t.closePath() } class O { static paintBase(t, e, i) { t.save(), t.fillStyle = null != i ? i : "rgba(0,0,0,0)", t.fillRect(0, 0, e.width, e.height), t.restore() } static clear(t, e) { t.clearRect(0, 0, e.width, e.height) } static drawLinkLine(t, e, i, o, n, s, a, c, l, h, d, u) { let p = !1; if (r.getDistance(i, o) <= n) T(t, i, o), p = !0; else if (a) { let e, a; const c = { x: o.x - s.width, y: o.y }, l = r.getDistances(i, c); if (l.distance <= n) { const t = i.y - l.dy / l.dx * i.x; e = { x: 0, y: t }, a = { x: s.width, y: t } } else { const t = { x: o.x, y: o.y - s.height }, c = r.getDistances(i, t); if (c.distance <= n) { const t = -(i.y - c.dy / c.dx * i.x) / (c.dy / c.dx); e = { x: t, y: 0 }, a = { x: t, y: s.height } } else { const t = { x: o.x - s.width, y: o.y - s.height }, c = r.getDistances(i, t); if (c.distance <= n) { const t = i.y - c.dy / c.dx * i.x; a = { x: (e = { x: -t / (c.dy / c.dx), y: t }).x + s.width, y: e.y + s.height } } } } e && a && (T(t, i, e), T(t, o, a), p = !0) } if (p) { if (t.lineWidth = e, c && (t.globalCompositeOperation = l), t.strokeStyle = R.getStyleFromRgb(h, d), u.enable) { const e = R.colorToRgb(u.color); e && (t.shadowBlur = u.blur, t.shadowColor = R.getStyleFromRgb(e)) } t.stroke() } } static drawLinkTriangle(t, e, i, o, n, s, a, r) { !function (t, e, i, o) { t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(i.x, i.y), t.lineTo(o.x, o.y), t.closePath() }(t, e, i, o), n && (t.globalCompositeOperation = s), t.fillStyle = R.getStyleFromRgb(a, r), t.fill() } static drawConnectLine(t, e, i, o, n) { t.save(), T(t, o, n), t.lineWidth = e, t.strokeStyle = i, t.stroke(), t.restore() } static gradient(t, e, i, o) { const n = Math.floor(i.getRadius() / e.getRadius()), s = e.getFillColor(), a = i.getFillColor(); if (!s || !a) return; const r = e.getPosition(), c = i.getPosition(), l = R.mix(s, a, e.getRadius(), i.getRadius()), h = t.createLinearGradient(r.x, r.y, c.x, c.y); return h.addColorStop(0, R.getStyleFromHsl(s, o)), h.addColorStop(n > 1 ? 1 : n, R.getStyleFromRgb(l, o)), h.addColorStop(1, R.getStyleFromHsl(a, o)), h } static drawGrabLine(t, e, i, o, n, s) { t.save(), T(t, i, o), t.strokeStyle = R.getStyleFromRgb(n, s), t.lineWidth = e, t.stroke(), t.restore() } static drawLight(t, e, i) { const o = t.actualOptions.interactivity.modes.light.area; e.beginPath(), e.arc(i.x, i.y, o.radius, 0, 2 * Math.PI); const n = e.createRadialGradient(i.x, i.y, 0, i.x, i.y, o.radius), s = o.gradient, a = { start: R.colorToRgb(s.start), stop: R.colorToRgb(s.stop) }; a.start && a.stop && (n.addColorStop(0, R.getStyleFromRgb(a.start)), n.addColorStop(1, R.getStyleFromRgb(a.stop)), e.fillStyle = n, e.fill()) } static drawParticleShadow(t, e, i, o) { const n = i.getPosition(), s = t.actualOptions.interactivity.modes.light.shadow; e.save(); const a = i.getRadius(), r = i.sides, c = 2 * Math.PI / r, l = -i.rotate.value + Math.PI / 4, h = []; for (let t = 0; t < r; t++)h.push({ x: n.x + a * Math.sin(l + c * t) * 1, y: n.y + a * Math.cos(l + c * t) * 1 }); const d = [], u = s.length; for (const t of h) { const e = Math.atan2(o.y - t.y, o.x - t.x), i = t.x + u * Math.sin(-e - Math.PI / 2), n = t.y + u * Math.cos(-e - Math.PI / 2); d.push({ endX: i, endY: n, startX: t.x, startY: t.y }) } const p = R.colorToRgb(s.color); if (!p) return; const v = R.getStyleFromRgb(p); for (let t = d.length - 1; t >= 0; t--) { const i = t == d.length - 1 ? 0 : t + 1; e.beginPath(), e.moveTo(d[t].startX, d[t].startY), e.lineTo(d[i].startX, d[i].startY), e.lineTo(d[i].endX, d[i].endY), e.lineTo(d[t].endX, d[t].endY), e.fillStyle = v, e.fill() } e.restore() } static drawParticle(t, e, i, o, n, s, a, r, c, l, h) { const d = i.getPosition(); e.save(), e.translate(d.x, d.y), e.beginPath(); const u = i.rotate.value + (i.options.rotate.path ? i.velocity.angle : 0); 0 !== u && e.rotate(u), a && (e.globalCompositeOperation = r); const p = i.shadowColor; h.enable && p && (e.shadowBlur = h.blur, e.shadowColor = R.getStyleFromRgb(p), e.shadowOffsetX = h.offset.x, e.shadowOffsetY = h.offset.y), n && (e.fillStyle = n); const v = i.stroke; e.lineWidth = i.strokeWidth, s && (e.strokeStyle = s), O.drawShape(t, e, i, c, l, o), v.width > 0 && e.stroke(), i.close && e.closePath(), i.fill && e.fill(), e.restore(), e.save(), e.translate(d.x, d.y), 0 !== u && e.rotate(u), a && (e.globalCompositeOperation = r), O.drawShapeAfterEffect(t, e, i, c, l, o), e.restore() } static drawShape(t, e, i, o, n, s) { if (!i.shape) return; const a = t.drawers.get(i.shape); a && a.draw(e, i, o, n, s.value, t.retina.pixelRatio) } static drawShapeAfterEffect(t, e, i, o, n, s) { if (!i.shape) return; const a = t.drawers.get(i.shape); (null == a ? void 0 : a.afterEffect) && a.afterEffect(e, i, o, n, s.value, t.retina.pixelRatio) } static drawPlugin(t, e, i) { void 0 !== e.draw && (t.save(), e.draw(t, i), t.restore()) } } class E { constructor(t, e) { this.position = { x: t, y: e } } } class k extends E { constructor(t, e, i) { super(t, e), this.radius = i } contains(t) { return Math.pow(t.x - this.position.x, 2) + Math.pow(t.y - this.position.y, 2) <= this.radius * this.radius } intersects(t) { const e = t, i = t, o = this.position, n = t.position, s = Math.abs(n.x - o.x), a = Math.abs(n.y - o.y), r = this.radius; if (void 0 !== i.radius) { return r + i.radius > Math.sqrt(s * s + a + a) } if (void 0 !== e.size) { const t = e.size.width, i = e.size.height, o = Math.pow(s - t, 2) + Math.pow(a - i, 2); return !(s > r + t || a > r + i) && (s <= t || a <= i || o <= r * r) } return !1 } } class M extends E { constructor(t, e, i, o) { super(t, e), this.size = { height: o, width: i } } contains(t) { const e = this.size.width, i = this.size.height, o = this.position; return t.x >= o.x && t.x <= o.x + e && t.y >= o.y && t.y <= o.y + i } intersects(t) { const e = t, i = t, o = this.size.width, n = this.size.height, s = this.position, a = t.position; if (void 0 !== i.radius) return i.intersects(this); if (void 0 !== e.size) { const t = e.size, i = t.width, r = t.height; return a.x < s.x + o && a.x + i > s.x && a.y < s.y + n && a.y + r > s.y } return !1 } } class L extends k { constructor(t, e, i, o) { super(t, e, i), this.canvasSize = o, this.canvasSize = { height: o.height, width: o.width } } contains(t) { if (super.contains(t)) return !0; const e = { x: t.x - this.canvasSize.width, y: t.y }; if (super.contains(e)) return !0; const i = { x: t.x - this.canvasSize.width, y: t.y - this.canvasSize.height }; if (super.contains(i)) return !0; const o = { x: t.x, y: t.y - this.canvasSize.height }; return super.contains(o) } intersects(t) { if (super.intersects(t)) return !0; const e = t, i = t, o = { x: t.position.x - this.canvasSize.width, y: t.position.y - this.canvasSize.height }; if (void 0 !== i.radius) { const t = new k(o.x, o.y, 2 * i.radius); return super.intersects(t) } if (void 0 !== e.size) { const t = new M(o.x, o.y, 2 * e.size.width, 2 * e.size.height); return super.intersects(t) } return !1 } } function I(t, e, i, o, n) { if (o) { let o = { passive: !0 }; "boolean" == typeof n ? o.capture = n : void 0 !== n && (o = n), t.addEventListener(e, i, o) } else { const o = n; t.removeEventListener(e, i, o) } } !function (t) { t.attract = "attract", t.bubble = "bubble", t.push = "push", t.remove = "remove", t.repulse = "repulse", t.pause = "pause", t.trail = "trail" }(c || (c = {})), function (t) { t.bounce = "bounce", t.bubble = "bubble", t.repulse = "repulse" }(l || (l = {})), function (t) { t.attract = "attract", t.bounce = "bounce", t.bubble = "bubble", t.connect = "connect", t.grab = "grab", t.light = "light", t.repulse = "repulse", t.slow = "slow", t.trail = "trail" }(h || (h = {})), function (t) { t.absorb = "absorb", t.bounce = "bounce", t.destroy = "destroy" }(d || (d = {})), function (t) { t.bounce = "bounce", t.bounceHorizontal = "bounce-horizontal", t.bounceVertical = "bounce-vertical", t.none = "none", t.out = "out", t.destroy = "destroy" }(u || (u = {})), function (t) { t.precise = "precise", t.percent = "percent" }(p || (p = {})), function (t) { t.any = "any", t.dark = "dark", t.light = "light" }(v || (v = {})), function (t) { t[t.increasing = 0] = "increasing", t[t.decreasing = 1] = "decreasing" }(g || (g = {})), function (t) { t.none = "none", t.max = "max", t.min = "min" }(y || (y = {})), function (t) { t.color = "color", t.opacity = "opacity", t.size = "size" }(f || (f = {})), function (t) { t.char = "char", t.character = "character", t.circle = "circle", t.edge = "edge", t.image = "image", t.images = "images", t.line = "line", t.polygon = "polygon", t.square = "square", t.star = "star", t.triangle = "triangle" }(m || (m = {})), function (t) { t.max = "max", t.min = "min", t.random = "random" }(w || (w = {})), function (t) { t.circle = "circle", t.rectangle = "rectangle" }(S || (S = {})), function (t) { t.canvas = "canvas", t.parent = "parent", t.window = "window" }(b || (b = {})); class z { constructor(t) { this.container = t, this.canPush = !0, this.mouseMoveHandler = (t => this.mouseTouchMove(t)), this.touchStartHandler = (t => this.mouseTouchMove(t)), this.touchMoveHandler = (t => this.mouseTouchMove(t)), this.touchEndHandler = (() => this.mouseTouchFinish()), this.mouseLeaveHandler = (() => this.mouseTouchFinish()), this.touchCancelHandler = (() => this.mouseTouchFinish()), this.touchEndClickHandler = (t => this.mouseTouchClick(t)), this.mouseUpHandler = (t => this.mouseTouchClick(t)), this.mouseDownHandler = (() => this.mouseDown()), this.visibilityChangeHandler = (() => this.handleVisibilityChange()), this.resizeHandler = (() => this.handleWindowResize()) } addListeners() { this.manageListeners(!0) } removeListeners() { this.manageListeners(!1) } manageListeners(t) { var e; const i = this.container, o = i.actualOptions, n = o.interactivity.detectsOn; let s = C.mouseLeaveEvent; if (n === b.window) i.interactivity.element = window, s = C.mouseOutEvent; else if (n === b.parent && i.canvas.element) { const t = i.canvas.element; i.interactivity.element = null !== (e = t.parentElement) && void 0 !== e ? e : t.parentNode } else i.interactivity.element = i.canvas.element; const a = i.interactivity.element; if (!a) return; const r = a; (o.interactivity.events.onHover.enable || o.interactivity.events.onClick.enable) && (I(a, C.mouseMoveEvent, this.mouseMoveHandler, t), I(a, C.touchStartEvent, this.touchStartHandler, t), I(a, C.touchMoveEvent, this.touchMoveHandler, t), o.interactivity.events.onClick.enable ? (I(a, C.touchEndEvent, this.touchEndClickHandler, t), I(a, C.mouseUpEvent, this.mouseUpHandler, t), I(a, C.mouseDownEvent, this.mouseDownHandler, t)) : I(a, C.touchEndEvent, this.touchEndHandler, t), I(a, s, this.mouseLeaveHandler, t), I(a, C.touchCancelEvent, this.touchCancelHandler, t)), i.canvas.element && (i.canvas.element.style.pointerEvents = r === i.canvas.element ? "initial" : "none"), o.interactivity.events.resize && I(window, C.resizeEvent, this.resizeHandler, t), document && I(document, C.visibilityChangeEvent, this.visibilityChangeHandler, t, !1) } handleWindowResize() { var t; null === (t = this.container.canvas) || void 0 === t || t.windowResize() } handleVisibilityChange() { const t = this.container, e = t.actualOptions; this.mouseTouchFinish(), e.pauseOnBlur && ((null === document || void 0 === document ? void 0 : document.hidden) ? (t.pageHidden = !0, t.pause()) : (t.pageHidden = !1, t.getAnimationStatus() ? t.play(!0) : t.draw())) } mouseDown() { const t = this.container.interactivity; if (t) { const e = t.mouse; e.clicking = !0, e.downPosition = e.position } } mouseTouchMove(t) { var e, i, o, n, s, a, r; const c = this.container, l = c.actualOptions; if (void 0 === (null === (e = c.interactivity) || void 0 === e ? void 0 : e.element)) return; let h; c.interactivity.mouse.inside = !0; const d = c.canvas.element; if (t.type.startsWith("mouse")) { this.canPush = !0; const e = t; if (c.interactivity.element === window) { if (d) { const t = d.getBoundingClientRect(); h = { x: e.clientX - t.left, y: e.clientY - t.top } } } else if (l.interactivity.detectsOn === b.parent) { const t = e.target, n = e.currentTarget, s = c.canvas.element; if (t && n && s) { const i = t.getBoundingClientRect(), o = n.getBoundingClientRect(), a = s.getBoundingClientRect(); h = { x: e.offsetX + 2 * i.left - (o.left + a.left), y: e.offsetY + 2 * i.top - (o.top + a.top) } } else h = { x: null !== (i = e.offsetX) && void 0 !== i ? i : e.clientX, y: null !== (o = e.offsetY) && void 0 !== o ? o : e.clientY } } else e.target === c.canvas.element && (h = { x: null !== (n = e.offsetX) && void 0 !== n ? n : e.clientX, y: null !== (s = e.offsetY) && void 0 !== s ? s : e.clientY }) } else { this.canPush = "touchmove" !== t.type; const e = t, i = e.touches[e.touches.length - 1], o = null == d ? void 0 : d.getBoundingClientRect(); h = { x: i.clientX - (null !== (a = null == o ? void 0 : o.left) && void 0 !== a ? a : 0), y: i.clientY - (null !== (r = null == o ? void 0 : o.top) && void 0 !== r ? r : 0) } } const u = c.retina.pixelRatio; h && (h.x *= u, h.y *= u), c.interactivity.mouse.position = h, c.interactivity.status = C.mouseMoveEvent } mouseTouchFinish() { const t = this.container.interactivity; if (void 0 === t) return; const e = t.mouse; delete e.position, delete e.clickPosition, delete e.downPosition, t.status = C.mouseLeaveEvent, e.inside = !1, e.clicking = !1 } mouseTouchClick(t) { const e = this.container, i = e.actualOptions, o = e.interactivity.mouse; o.inside = !0; let n = !1; const s = o.position; if (void 0 !== s && i.interactivity.events.onClick.enable) { for (const [, t] of e.plugins) if (void 0 !== t.clickPositionValid && (n = t.clickPositionValid(s))) break; n || this.doMouseTouchClick(t), o.clicking = !1 } } doMouseTouchClick(t) { const e = this.container, i = e.actualOptions; if (this.canPush) { const t = e.interactivity.mouse.position; if (!t) return; e.interactivity.mouse.clickPosition = { x: t.x, y: t.y }, e.interactivity.mouse.clickTime = (new Date).getTime(); const o = i.interactivity.events.onClick; if (o.mode instanceof Array) for (const t of o.mode) this.handleClickMode(t); else this.handleClickMode(o.mode) } "touchend" === t.type && setTimeout(() => this.mouseTouchFinish(), 500) } handleClickMode(t) { const e = this.container, i = e.actualOptions, o = i.interactivity.modes.push.quantity, n = i.interactivity.modes.remove.quantity; switch (t) { case c.push: o > 0 && e.particles.push(o, e.interactivity.mouse); break; case c.remove: e.particles.removeQuantity(n); break; case c.bubble: e.bubble.clicking = !0; break; case c.repulse: e.repulse.clicking = !0, e.repulse.count = 0; for (const t of e.repulse.particles) t.velocity.setTo(t.initialVelocity); e.repulse.particles = [], e.repulse.finish = !1, setTimeout(() => { e.destroyed || (e.repulse.clicking = !1) }, 1e3 * i.interactivity.modes.repulse.duration); break; case c.attract: e.attract.clicking = !0, e.attract.count = 0; for (const t of e.attract.particles) t.velocity.setTo(t.initialVelocity); e.attract.particles = [], e.attract.finish = !1, setTimeout(() => { e.destroyed || (e.attract.clicking = !1) }, 1e3 * i.interactivity.modes.attract.duration); break; case c.pause: e.getAnimationStatus() ? e.pause() : e.play() }for (const [, i] of e.plugins) i.handleClickMode && i.handleClickMode(t) } } const H = [], D = new Map, F = new Map, N = new Map; class B { static getPlugin(t) { return H.find(e => e.id === t) } static addPlugin(t) { B.getPlugin(t.id) || H.push(t) } static getAvailablePlugins(t) { const e = new Map; for (const i of H) i.needsPlugin(t.actualOptions) && e.set(i.id, i.getPlugin(t)); return e } static loadOptions(t, e) { for (const i of H) i.loadOptions(t, e) } static getPreset(t) { return D.get(t) } static addPreset(t, e) { B.getPreset(t) || D.set(t, e) } static addShapeDrawer(t, e) { B.getShapeDrawer(t) || F.set(t, e) } static getShapeDrawer(t) { return F.get(t) } static getSupportedShapes() { return F.keys() } static getPathGenerator(t) { return N.get(t) } static addPathGenerator(t, e) { B.getPathGenerator(t) || N.set(t, e) } } class j { constructor(t, e) { this.position = t, this.particle = e } } class q { constructor(t, e) { this.rectangle = t, this.capacity = e, this.points = [], this.divided = !1 } subdivide() { const t = this.rectangle.position.x, e = this.rectangle.position.y, i = this.rectangle.size.width, o = this.rectangle.size.height, n = this.capacity; this.northEast = new q(new M(t, e, i / 2, o / 2), n), this.northWest = new q(new M(t + i / 2, e, i / 2, o / 2), n), this.southEast = new q(new M(t, e + o / 2, i / 2, o / 2), n), this.southWest = new q(new M(t + i / 2, e + o / 2, i / 2, o / 2), n), this.divided = !0 } insert(t) { var e, i, o, n, s; return !!this.rectangle.contains(t.position) && (this.points.length < this.capacity ? (this.points.push(t), !0) : (this.divided || this.subdivide(), null !== (s = (null === (e = this.northEast) || void 0 === e ? void 0 : e.insert(t)) || (null === (i = this.northWest) || void 0 === i ? void 0 : i.insert(t)) || (null === (o = this.southEast) || void 0 === o ? void 0 : o.insert(t)) || (null === (n = this.southWest) || void 0 === n ? void 0 : n.insert(t))) && void 0 !== s && s)) } queryCircle(t, e) { return this.query(new k(t.x, t.y, e)) } queryCircleWarp(t, e, i) { const o = i, n = i; return this.query(new L(t.x, t.y, e, void 0 !== o.canvas ? o.canvas.size : n)) } queryRectangle(t, e) { return this.query(new M(t.x, t.y, e.width, e.height)) } query(t, e) { var i, o, n, s; const a = null != e ? e : []; if (!t.intersects(this.rectangle)) return []; for (const e of this.points) t.contains(e.position) && a.push(e.particle); return this.divided && (null === (i = this.northEast) || void 0 === i || i.query(t, a), null === (o = this.northWest) || void 0 === o || o.query(t, a), null === (n = this.southEast) || void 0 === n || n.query(t, a), null === (s = this.southWest) || void 0 === s || s.query(t, a)), a } } var U = function (t, e, i, o) { return new (i || (i = Promise))(function (n, s) { function a(t) { try { c(o.next(t)) } catch (t) { s(t) } } function r(t) { try { c(o.throw(t)) } catch (t) { s(t) } } function c(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) { t(e) })).then(a, r) } c((o = o.apply(t, e || [])).next()) }) }; class Q { getSidesCount() { return 12 } init(t) { var e; return U(this, void 0, void 0, function* () { const i = t.actualOptions; if (A.isInArray(m.char, i.particles.shape.type) || A.isInArray(m.character, i.particles.shape.type)) { const t = null !== (e = i.particles.shape.options[m.character]) && void 0 !== e ? e : i.particles.shape.options[m.char]; if (t instanceof Array) for (const e of t) yield A.loadFont(e); else void 0 !== t && (yield A.loadFont(t)) } }) } draw(t, e, i) { const o = e.shapeData; if (void 0 === o) return; const n = o.value; if (void 0 === n) return; const s = e; void 0 === s.text && (s.text = n instanceof Array ? A.itemFromArray(n, e.randomIndexData) : n); const a = s.text, r = o.style, c = o.weight, l = 2 * Math.round(i), h = o.font, d = e.fill, u = a.length * i / 2; t.font = `${r} ${c} ${l}px "${h}"`; const p = { x: -u, y: i / 2 }; d ? t.fillText(a, p.x, p.y) : t.strokeText(a, p.x, p.y) } } var W = function (t, e, i, o) { return new (i || (i = Promise))(function (n, s) { function a(t) { try { c(o.next(t)) } catch (t) { s(t) } } function r(t) { try { c(o.throw(t)) } catch (t) { s(t) } } function c(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) { t(e) })).then(a, r) } c((o = o.apply(t, e || [])).next()) }) }; class $ { constructor() { this.images = [] } getSidesCount() { return 12 } getImages(t) { const e = this.images.filter(e => e.id === t.id); return e.length ? e[0] : (this.images.push({ id: t.id, images: [] }), this.getImages(t)) } addImage(t, e) { const i = this.getImages(t); null == i || i.images.push(e) } init(t) { var e; return W(this, void 0, void 0, function* () { const i = t.actualOptions.particles.shape; if (!A.isInArray(m.image, i.type) && !A.isInArray(m.images, i.type)) return; const o = null !== (e = i.options[m.images]) && void 0 !== e ? e : i.options[m.image]; if (o instanceof Array) for (const e of o) yield this.loadImageShape(t, e); else yield this.loadImageShape(t, o) }) } destroy() { this.images = [] } loadImageShape(t, e) { return W(this, void 0, void 0, function* () { try { const i = e.replaceColor ? yield A.downloadSvgImage(e.src) : yield A.loadImage(e.src); i && this.addImage(t, i) } catch (t) { console.warn(`tsParticles error - ${e.src} not found`) } }) } draw(t, e, i, o) { var n, s; if (!t) return; const a = e.image, r = null === (n = null == a ? void 0 : a.data) || void 0 === n ? void 0 : n.element; if (!r) return; const c = null !== (s = null == a ? void 0 : a.ratio) && void 0 !== s ? s : 1, l = { x: -i, y: -i }; (null == a ? void 0 : a.data.svgData) && (null == a ? void 0 : a.replaceColor) || (t.globalAlpha = o), t.drawImage(r, l.x, l.y, 2 * i, 2 * i / c), (null == a ? void 0 : a.data.svgData) && (null == a ? void 0 : a.replaceColor) || (t.globalAlpha = 1) } } class X { getSidesCount() { return 1 } draw(t, e, i) { t.moveTo(0, -i / 2), t.lineTo(0, i / 2) } } class Y { getSidesCount() { return 12 } draw(t, e, i) { t.arc(0, 0, i, 0, 2 * Math.PI, !1) } } class J { getSidesCount(t) { var e, i; const o = t.shapeData; return null !== (i = null !== (e = null == o ? void 0 : o.sides) && void 0 !== e ? e : null == o ? void 0 : o.nb_sides) && void 0 !== i ? i : 5 } draw(t, e, i) { const o = this.getCenter(e, i), n = this.getSidesData(e, i), s = n.count.numerator * n.count.denominator, a = n.count.numerator / n.count.denominator, r = 180 * (a - 2) / a, c = Math.PI - Math.PI * r / 180; if (t) { t.beginPath(), t.translate(o.x, o.y), t.moveTo(0, 0); for (let e = 0; e < s; e++)t.lineTo(n.length, 0), t.translate(n.length, 0), t.rotate(c) } } } class Z extends J { getSidesCount() { return 3 } getSidesData(t, e) { return { count: { denominator: 2, numerator: 3 }, length: 2 * e } } getCenter(t, e) { return { x: -e, y: e / 1.66 } } } class K { getSidesCount(t) { var e, i; const o = t.shapeData; return null !== (i = null !== (e = null == o ? void 0 : o.sides) && void 0 !== e ? e : null == o ? void 0 : o.nb_sides) && void 0 !== i ? i : 5 } draw(t, e, i) { var o; const n = e.shapeData, s = this.getSidesCount(e), a = null !== (o = null == n ? void 0 : n.inset) && void 0 !== o ? o : 2; t.moveTo(0, 0 - i); for (let e = 0; e < s; e++)t.rotate(Math.PI / s), t.lineTo(0, 0 - i * a), t.rotate(Math.PI / s), t.lineTo(0, 0 - i) } } class tt extends J { getSidesData(t, e) { var i, o; const n = t.shapeData, s = null !== (o = null !== (i = null == n ? void 0 : n.sides) && void 0 !== i ? i : null == n ? void 0 : n.nb_sides) && void 0 !== o ? o : 5; return { count: { denominator: 1, numerator: s }, length: 2.66 * e / (s / 3) } } getCenter(t, e) { return { x: -e / (this.getSidesCount(t) / 3.5), y: -e / .76 } } } class et { constructor(t) { this.container = t, this.size = { height: 0, width: 0 }, this.context = null, this.generatedCanvas = !1 } init() { var t, e, i, o, n, s, a, r, c, l, h, d; this.resize(); const u = this.container.actualOptions, p = this.element; p && (u.fullScreen.enable ? (this.originalStyle = A.deepExtend({}, p.style), p.style.position = "fixed", p.style.zIndex = u.fullScreen.zIndex.toString(10), p.style.top = "0", p.style.left = "0", p.style.width = "100%", p.style.height = "100%") : (p.style.position = null !== (e = null === (t = this.originalStyle) || void 0 === t ? void 0 : t.position) && void 0 !== e ? e : "", p.style.zIndex = null !== (o = null === (i = this.originalStyle) || void 0 === i ? void 0 : i.zIndex) && void 0 !== o ? o : "", p.style.top = null !== (s = null === (n = this.originalStyle) || void 0 === n ? void 0 : n.top) && void 0 !== s ? s : "", p.style.left = null !== (r = null === (a = this.originalStyle) || void 0 === a ? void 0 : a.left) && void 0 !== r ? r : "", p.style.width = null !== (l = null === (c = this.originalStyle) || void 0 === c ? void 0 : c.width) && void 0 !== l ? l : "", p.style.height = null !== (d = null === (h = this.originalStyle) || void 0 === h ? void 0 : h.height) && void 0 !== d ? d : "")); const v = u.backgroundMask.cover, g = v.color, y = u.particles.move.trail, f = R.colorToRgb(g); this.coverColor = void 0 !== f ? { r: f.r, g: f.g, b: f.b, a: v.opacity } : void 0, this.trailFillColor = R.colorToRgb(y.fillColor), this.initBackground(), this.paint() } loadCanvas(t, e) { var i; t.className || (t.className = C.canvasClass), this.generatedCanvas && (null === (i = this.element) || void 0 === i || i.remove()), this.generatedCanvas = null != e ? e : this.generatedCanvas, this.element = t, this.originalStyle = A.deepExtend({}, this.element.style), this.size.height = t.offsetHeight, this.size.width = t.offsetWidth, this.context = this.element.getContext("2d"), this.container.retina.init(), this.initBackground() } destroy() { var t; this.generatedCanvas && (null === (t = this.element) || void 0 === t || t.remove()), this.context && O.clear(this.context, this.size) } paint() { const t = this.container.actualOptions; this.context && (t.backgroundMask.enable && t.backgroundMask.cover && this.coverColor ? (O.clear(this.context, this.size), this.paintBase(R.getStyleFromRgb(this.coverColor, this.coverColor.a))) : this.paintBase()) } clear() { const t = this.container.actualOptions, e = t.particles.move.trail; t.backgroundMask.enable ? this.paint() : e.enable && e.length > 0 && this.trailFillColor ? this.paintBase(R.getStyleFromRgb(this.trailFillColor, 1 / e.length)) : this.context && O.clear(this.context, this.size) } windowResize() { if (!this.element) return; const t = this.container; t.canvas.resize(), t.actualOptions.setResponsive(this.size.width, t.retina.pixelRatio, t.options), t.particles.setDensity(); for (const [, e] of t.plugins) void 0 !== e.resize && e.resize() } resize() { if (!this.element) return; const t = this.container, e = t.retina.pixelRatio, i = t.canvas.size, o = i.width, n = i.height; i.width = this.element.offsetWidth * e, i.height = this.element.offsetHeight * e, this.element.width = i.width, this.element.height = i.height, this.resizeFactor = { width: i.width / o, height: i.height / n } } drawConnectLine(t, e) { var i; const o = this.context; if (!o) return; const n = this.lineStyle(t, e); if (!n) return; const s = t.getPosition(), a = e.getPosition(); O.drawConnectLine(o, null !== (i = t.linksWidth) && void 0 !== i ? i : this.container.retina.linksWidth, n, s, a) } drawGrabLine(t, e, i, o) { var n; const s = this.container, a = s.canvas.context; if (!a) return; const r = t.getPosition(); O.drawGrabLine(a, null !== (n = t.linksWidth) && void 0 !== n ? n : s.retina.linksWidth, r, o, e, i) } drawParticleShadow(t, e) { this.context && O.drawParticleShadow(this.container, this.context, t, e) } drawLinkTriangle(t, e, i) { var o; const n = this.container, s = n.actualOptions, a = e.destination, c = i.destination, l = t.options.links.triangles, h = null !== (o = l.opacity) && void 0 !== o ? o : (e.opacity + i.opacity) / 2; if (h <= 0) return; const d = t.getPosition(), u = a.getPosition(), p = c.getPosition(), v = this.context; if (!v) return; if (r.getDistance(d, u) > n.retina.linksDistance || r.getDistance(p, u) > n.retina.linksDistance || r.getDistance(p, d) > n.retina.linksDistance) return; let g = R.colorToRgb(l.color); if (!g) { const e = t.options.links, i = void 0 !== e.id ? n.particles.linksColors.get(e.id) : n.particles.linksColor; g = R.getLinkColor(t, a, i) } g && O.drawLinkTriangle(v, d, u, p, s.backgroundMask.enable, s.backgroundMask.composite, g, h) } drawLinkLine(t, e) { var i, o; const n = this.container, s = n.actualOptions, a = e.destination; let r = e.opacity; const c = t.getPosition(), l = a.getPosition(), h = this.context; if (!h) return; let d; const u = t.options.twinkle.lines; if (u.enable) { const t = u.frequency, e = R.colorToRgb(u.color); Math.random() < t && void 0 !== e && (d = e, r = u.opacity) } if (!d) { const e = t.options.links, i = void 0 !== e.id ? n.particles.linksColors.get(e.id) : n.particles.linksColor; d = R.getLinkColor(t, a, i) } if (!d) return; const p = null !== (i = t.linksWidth) && void 0 !== i ? i : n.retina.linksWidth, v = null !== (o = t.linksDistance) && void 0 !== o ? o : n.retina.linksDistance; O.drawLinkLine(h, p, c, l, v, n.canvas.size, t.options.links.warp, s.backgroundMask.enable, s.backgroundMask.composite, d, r, t.options.links.shadow) } drawParticle(t, e) { var i, o, n, s; if (!1 === (null === (i = t.image) || void 0 === i ? void 0 : i.loaded) || t.spawning || t.destroyed) return; const a = t.getFillColor(), r = null !== (o = t.getStrokeColor()) && void 0 !== o ? o : a; if (!a && !r) return; const c = this.container.actualOptions, l = t.options.twinkle.particles, h = l.frequency, d = R.colorToRgb(l.color), u = l.enable && Math.random() < h, p = t.getRadius(), v = u ? l.opacity : null !== (n = t.bubble.opacity) && void 0 !== n ? n : t.opacity.value, g = t.infecter.infectionStage, y = c.infection.stages, f = void 0 !== g ? y[g].color : void 0, m = R.colorToRgb(f), w = u && void 0 !== d ? d : null != m ? m : a ? R.hslToRgb(a) : void 0, S = u && void 0 !== d ? d : null != m ? m : r ? R.hslToRgb(r) : void 0, b = void 0 !== w ? R.getStyleFromRgb(w, v) : void 0; if (!this.context || !b && !S) return; const P = void 0 !== S ? R.getStyleFromRgb(S, null !== (s = t.stroke.opacity) && void 0 !== s ? s : v) : b; this.drawParticleLinks(t), p > 0 && O.drawParticle(this.container, this.context, t, e, b, P, c.backgroundMask.enable, c.backgroundMask.composite, p, v, t.options.shadow) } drawParticleLinks(t) { if (!this.context) return; const e = this.container, i = e.particles, o = t.options; if (t.links.length > 0) { this.context.save(); const n = t.links.filter(i => { return e.particles.getLinkFrequency(t, i.destination) <= o.links.frequency }); for (const s of n) { const a = s.destination; if (o.links.triangles.enable) { const r = n.map(t => t.destination), c = a.links.filter(t => { return e.particles.getLinkFrequency(a, t.destination) <= a.options.links.frequency && r.indexOf(t.destination) >= 0 }); if (c.length) for (const e of c) { const n = e.destination; i.getTriangleFrequency(t, a, n) > o.links.triangles.frequency || this.drawLinkTriangle(t, s, e) } } s.opacity > 0 && e.retina.linksWidth > 0 && this.drawLinkLine(t, s) } this.context.restore() } } drawPlugin(t, e) { this.context && O.drawPlugin(this.context, t, e) } drawLight(t) { this.context && O.drawLight(this.container, this.context, t) } paintBase(t) { this.context && O.paintBase(this.context, this.size, t) } lineStyle(t, e) { if (!this.context) return; const i = this.container.actualOptions.interactivity.modes.connect; return O.gradient(this.context, t, e, i.links.opacity) } initBackground() { const t = this.container.actualOptions.background, e = this.element, i = null == e ? void 0 : e.style; if (i) { if (t.color) { const e = R.colorToRgb(t.color); i.backgroundColor = e ? R.getStyleFromRgb(e, t.opacity) : "" } else i.backgroundColor = ""; i.backgroundImage = t.image || "", i.backgroundPosition = t.position || "", i.backgroundRepeat = t.repeat || "", i.backgroundSize = t.size || "" } } } function it(t, e, i, o, n) { switch (e) { case y.max: i >= n && t.destroy(); break; case y.min: i <= o && t.destroy() } } class ot { constructor(t, e) { this.container = t, this.particle = e } update(t) { this.particle.destroyed || (this.updateLife(t), this.particle.destroyed || this.particle.spawning || (this.updateOpacity(t), this.updateSize(t), this.updateAngle(t), this.updateColor(t), this.updateStrokeColor(t), this.updateOutModes(t))) } updateLife(t) { const e = this.particle; let i = !1; if (e.spawning && (e.lifeDelayTime += t.value, e.lifeDelayTime >= e.lifeDelay && (i = !0, e.spawning = !1, e.lifeDelayTime = 0, e.lifeTime = 0)), -1 !== e.lifeDuration && !e.spawning && (i ? e.lifeTime = 0 : e.lifeTime += t.value, e.lifeTime >= e.lifeDuration)) { if (e.lifeTime = 0, e.livesRemaining > 0 && e.livesRemaining--, 0 === e.livesRemaining) return void e.destroy(); const t = this.container.canvas.size; e.position.x = r.randomInRange(r.setRangeValue(0, t.width)), e.position.y = r.randomInRange(r.setRangeValue(0, t.height)), e.spawning = !0, e.lifeDelayTime = 0, e.lifeTime = 0, e.reset(); const i = e.options.life; e.lifeDelay = 1e3 * r.getValue(i.delay), e.lifeDuration = 1e3 * r.getValue(i.duration) } } updateOpacity(t) { var e, i; const o = this.particle, n = o.options.opacity, s = n.animation, a = r.getRangeMin(n.value), c = r.getRangeMax(n.value); if (!o.destroyed && s.enable && (s.count <= 0 || o.loops.size < s.count)) { switch (o.opacity.status) { case g.increasing: o.opacity.value >= c ? (o.opacity.status = g.decreasing, o.loops.opacity++) : o.opacity.value += (null !== (e = o.opacity.velocity) && void 0 !== e ? e : 0) * t.factor; break; case g.decreasing: o.opacity.value <= a ? (o.opacity.status = g.increasing, o.loops.opacity++) : o.opacity.value -= (null !== (i = o.opacity.velocity) && void 0 !== i ? i : 0) * t.factor }it(o, s.destroy, o.opacity.value, a, c), o.destroyed || (o.opacity.value = r.clamp(o.opacity.value, a, c)) } } updateSize(t) { var e; const i = this.container, o = this.particle, n = o.options.size, s = n.animation, a = (null !== (e = o.size.velocity) && void 0 !== e ? e : 0) * t.factor, c = r.getRangeMin(n.value) * i.retina.pixelRatio, l = r.getRangeMax(n.value) * i.retina.pixelRatio; if (!o.destroyed && s.enable && (s.count <= 0 || o.loops.size < s.count)) { switch (o.size.status) { case g.increasing: o.size.value >= l ? (o.size.status = g.decreasing, o.loops.size++) : o.size.value += a; break; case g.decreasing: o.size.value <= c ? (o.size.status = g.increasing, o.loops.size++) : o.size.value -= a }it(o, s.destroy, o.size.value, c, l), o.destroyed || (o.size.value = r.clamp(o.size.value, c, l)) } } updateAngle(t) { var e; const i = this.particle, o = i.options.rotate.animation, n = (null !== (e = i.rotate.velocity) && void 0 !== e ? e : 0) * t.factor, s = 2 * Math.PI; if (o.enable) switch (i.rotate.status) { case g.increasing: i.rotate.value += n, i.rotate.value > s && (i.rotate.value -= s); break; case g.decreasing: default: i.rotate.value -= n, i.rotate.value < 0 && (i.rotate.value += s) } } updateColor(t) { var e, i, o; const n = this.particle, s = n.options.color.animation; void 0 !== (null === (e = n.color) || void 0 === e ? void 0 : e.h) && this.updateColorValue(n, t, n.color.h, s.h, 360, !1), void 0 !== (null === (i = n.color) || void 0 === i ? void 0 : i.s) && this.updateColorValue(n, t, n.color.s, s.s, 100, !0), void 0 !== (null === (o = n.color) || void 0 === o ? void 0 : o.l) && this.updateColorValue(n, t, n.color.l, s.l, 100, !0) } updateStrokeColor(t) { var e, i, o, n, s, a, r, c, l, h, d, u; const p = this.particle; if (!p.stroke.color) return; const v = p.stroke.color.animation, g = v; if (void 0 !== g.enable) { const n = null !== (i = null === (e = p.strokeColor) || void 0 === e ? void 0 : e.h) && void 0 !== i ? i : null === (o = p.color) || void 0 === o ? void 0 : o.h; n && this.updateColorValue(p, t, n, g, 360, !1) } else { const e = v, i = null !== (s = null === (n = p.strokeColor) || void 0 === n ? void 0 : n.h) && void 0 !== s ? s : null === (a = p.color) || void 0 === a ? void 0 : a.h; i && this.updateColorValue(p, t, i, e.h, 360, !1); const o = null !== (c = null === (r = p.strokeColor) || void 0 === r ? void 0 : r.s) && void 0 !== c ? c : null === (l = p.color) || void 0 === l ? void 0 : l.s; o && this.updateColorValue(p, t, o, e.s, 100, !0); const g = null !== (d = null === (h = p.strokeColor) || void 0 === h ? void 0 : h.l) && void 0 !== d ? d : null === (u = p.color) || void 0 === u ? void 0 : u.l; g && this.updateColorValue(p, t, g, e.l, 100, !0) } } updateColorValue(t, e, i, o, n, s) { var a; const c = i; if (!c || !o.enable) return; const l = r.randomInRange(o.offset), h = (null !== (a = i.velocity) && void 0 !== a ? a : 0) * e.factor + 3.6 * l; s && c.status !== g.increasing ? (c.value -= h, c.value < 0 && (c.status = g.increasing, c.value += c.value)) : (c.value += h, s && c.value > n && (c.status = g.decreasing, c.value -= c.value % n)), c.value > n && (c.value %= n) } updateOutModes(t) { var e, i, n, s; const a = this.particle.options.move.outModes; this.updateOutMode(t, null !== (e = a.bottom) && void 0 !== e ? e : a.default, o.bottom), this.updateOutMode(t, null !== (i = a.left) && void 0 !== i ? i : a.default, o.left), this.updateOutMode(t, null !== (n = a.right) && void 0 !== n ? n : a.default, o.right), this.updateOutMode(t, null !== (s = a.top) && void 0 !== s ? s : a.default, o.top) } updateOutMode(t, e, i) { const o = this.container, n = this.particle; switch (e) { case u.bounce: case u.bounceVertical: case u.bounceHorizontal: case "bounceVertical": case "bounceHorizontal": this.updateBounce(t, i, e); break; case u.destroy: A.isPointInside(n.position, o.canvas.size, n.getRadius(), i) || o.particles.remove(n); break; case u.out: A.isPointInside(n.position, o.canvas.size, n.getRadius(), i) || this.fixOutOfCanvasPosition(i); break; case u.none: this.bounceNone(i) } } fixOutOfCanvasPosition(t) { const e = this.container, i = this.particle, n = i.options.move.warp, s = e.canvas.size, a = { bottom: s.height + i.getRadius() - i.offset.y, left: -i.getRadius() - i.offset.x, right: s.width + i.getRadius() + i.offset.x, top: -i.getRadius() - i.offset.y }, r = i.getRadius(), c = A.calculateBounds(i.position, r); t === o.right && c.left > s.width - i.offset.x ? (i.position.x = a.left, n || (i.position.y = Math.random() * s.height)) : t === o.left && c.right < -i.offset.x && (i.position.x = a.right, n || (i.position.y = Math.random() * s.height)), t === o.bottom && c.top > s.height - i.offset.y ? (n || (i.position.x = Math.random() * s.width), i.position.y = a.top) : t === o.top && c.bottom < -i.offset.y && (n || (i.position.x = Math.random() * s.width), i.position.y = a.bottom) } updateBounce(t, e, i) { const n = this.container, s = this.particle; let a = !1; for (const [, i] of n.plugins) if (void 0 !== i.particleBounce && (a = i.particleBounce(s, t, e)), a) break; if (a) return; const c = s.getPosition(), l = s.offset, h = s.getRadius(), d = A.calculateBounds(c, h), p = n.canvas.size; !function (t) { if (t.outMode === u.bounce || t.outMode === u.bounceHorizontal || "bounceHorizontal" === t.outMode) { const e = t.particle.velocity.x; let i = !1; if (t.direction === o.right && t.bounds.right >= t.canvasSize.width && e > 0 || t.direction === o.left && t.bounds.left <= 0 && e < 0) { const e = r.getValue(t.particle.options.bounce.horizontal); t.particle.velocity.x *= -e, i = !0 } if (i) { const e = t.offset.x + t.size; t.bounds.right >= t.canvasSize.width ? t.particle.position.x = t.canvasSize.width - e : t.bounds.left <= 0 && (t.particle.position.x = e) } } }({ particle: s, outMode: i, direction: e, bounds: d, canvasSize: p, offset: l, size: h }), function (t) { if (t.outMode === u.bounce || t.outMode === u.bounceVertical || "bounceVertical" === t.outMode) { const e = t.particle.velocity.y; let i = !1; if (t.direction === o.bottom && t.bounds.bottom >= t.canvasSize.height && e > 0 || t.direction === o.top && t.bounds.top <= 0 && e < 0) { const e = r.getValue(t.particle.options.bounce.vertical); t.particle.velocity.y *= -e, i = !0 } if (i) { const e = t.offset.y + t.size; t.bounds.bottom >= t.canvasSize.height ? t.particle.position.y = t.canvasSize.height - e : t.bounds.top <= 0 && (t.particle.position.y = e) } } }({ particle: s, outMode: i, direction: e, bounds: d, canvasSize: p, offset: l, size: h }) } bounceNone(t) { const e = this.particle; if (e.options.move.distance) return; const i = e.options.move.gravity, n = this.container; if (i.enable) { const s = e.position; (i.acceleration >= 0 && s.y > n.canvas.size.height && t === o.bottom || i.acceleration < 0 && s.y < 0 && t === o.top) && n.particles.remove(e) } else A.isPointInside(e.position, n.canvas.size, e.getRadius(), t) || n.particles.remove(e) } } class nt { constructor() { this.value = "#fff" } static create(t, e) { const i = null != t ? t : new nt; return void 0 !== e && i.load("string" == typeof e ? { value: e } : e), i } load(t) { void 0 !== (null == t ? void 0 : t.value) && (this.value = t.value) } } class st { constructor() { this.blur = 5, this.color = new nt, this.enable = !1, this.color.value = "#00ff00" } load(t) { void 0 !== t && (void 0 !== t.blur && (this.blur = t.blur), this.color = nt.create(this.color, t.color), void 0 !== t.enable && (this.enable = t.enable)) } } class at { constructor() { this.enable = !1, this.frequency = 1 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = nt.create(this.color, t.color)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.frequency && (this.frequency = t.frequency), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class rt { constructor() { this.blink = !1, this.color = new nt, this.consent = !1, this.distance = 100, this.enable = !1, this.frequency = 1, this.opacity = 1, this.shadow = new st, this.triangles = new at, this.width = 1, this.warp = !1 } load(t) { void 0 !== t && (void 0 !== t.id && (this.id = t.id), void 0 !== t.blink && (this.blink = t.blink), this.color = nt.create(this.color, t.color), void 0 !== t.consent && (this.consent = t.consent), void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.frequency && (this.frequency = t.frequency), void 0 !== t.opacity && (this.opacity = t.opacity), this.shadow.load(t.shadow), this.triangles.load(t.triangles), void 0 !== t.width && (this.width = t.width), void 0 !== t.warp && (this.warp = t.warp)) } } class ct { constructor() { this.enable = !1, this.rotate = { x: 3e3, y: 3e3 } } get rotateX() { return this.rotate.x } set rotateX(t) { this.rotate.x = t } get rotateY() { return this.rotate.y } set rotateY(t) { this.rotate.y = t } load(t) { var e, i, o, n; if (void 0 === t) return; void 0 !== t.enable && (this.enable = t.enable); const s = null !== (i = null === (e = t.rotate) || void 0 === e ? void 0 : e.x) && void 0 !== i ? i : t.rotateX; void 0 !== s && (this.rotate.x = s); const a = null !== (n = null === (o = t.rotate) || void 0 === o ? void 0 : o.y) && void 0 !== n ? n : t.rotateY; void 0 !== a && (this.rotate.y = a) } } class lt { constructor() { this.enable = !1, this.length = 10, this.fillColor = new nt, this.fillColor.value = "#000000" } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), this.fillColor = nt.create(this.fillColor, t.fillColor), void 0 !== t.length && (this.length = t.length)) } } class ht { constructor() { this.enable = !1, this.minimumValue = 0 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.minimumValue && (this.minimumValue = t.minimumValue)) } } class dt { constructor() { this.random = new ht, this.value = 0 } load(t) { t && ("boolean" == typeof t.random ? this.random.enable = t.random : this.random.load(t.random), void 0 !== t.value && (this.value = r.setRangeValue(t.value, this.random.enable ? this.random.minimumValue : void 0))) } } class ut extends dt { constructor() { super() } } class pt { constructor() { this.clamp = !0, this.delay = new ut, this.enable = !1 } load(t) { void 0 !== t && (void 0 !== t.clamp && (this.clamp = t.clamp), this.delay.load(t.delay), void 0 !== t.enable && (this.enable = t.enable), this.generator = t.generator) } } class vt { constructor() { this.offset = 45, this.value = 90 } load(t) { void 0 !== t && (void 0 !== t.offset && (this.offset = t.offset), void 0 !== t.value && (this.value = t.value)) } } class gt { constructor() { this.acceleration = 9.81, this.enable = !1, this.maxSpeed = 50 } load(t) { t && (void 0 !== t.acceleration && (this.acceleration = t.acceleration), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.maxSpeed && (this.maxSpeed = t.maxSpeed)) } } class yt { constructor() { this.default = u.out } load(t) { var e, i, o, n; t && (void 0 !== t.default && (this.default = t.default), this.bottom = null !== (e = t.bottom) && void 0 !== e ? e : t.default, this.left = null !== (i = t.left) && void 0 !== i ? i : t.default, this.right = null !== (o = t.right) && void 0 !== o ? o : t.default, this.top = null !== (n = t.top) && void 0 !== n ? n : t.default) } } class ft { constructor() { this.angle = new vt, this.attract = new ct, this.decay = 0, this.distance = 0, this.direction = n.none, this.drift = 0, this.enable = !1, this.gravity = new gt, this.path = new pt, this.outModes = new yt, this.random = !1, this.size = !1, this.speed = 2, this.straight = !1, this.trail = new lt, this.vibrate = !1, this.warp = !1 } get collisions() { return !1 } set collisions(t) { } get bounce() { return this.collisions } set bounce(t) { this.collisions = t } get out_mode() { return this.outMode } set out_mode(t) { this.outMode = t } get outMode() { return this.outModes.default } set outMode(t) { this.outModes.default = t } get noise() { return this.path } set noise(t) { this.path = t } load(t) { var e, i, o; if (void 0 === t) return; void 0 !== t.angle && ("number" == typeof t.angle ? this.angle.value = t.angle : this.angle.load(t.angle)), this.attract.load(t.attract), void 0 !== t.decay && (this.decay = t.decay), void 0 !== t.direction && (this.direction = t.direction), void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.drift && (this.drift = r.setRangeValue(t.drift)), void 0 !== t.enable && (this.enable = t.enable), this.gravity.load(t.gravity); const n = null !== (e = t.outMode) && void 0 !== e ? e : t.out_mode; void 0 === t.outModes && void 0 === n || ("string" == typeof t.outModes || void 0 === t.outModes && void 0 !== n ? this.outModes.load({ default: null !== (i = t.outModes) && void 0 !== i ? i : n }) : this.outModes.load(t.outModes)), this.path.load(null !== (o = t.path) && void 0 !== o ? o : t.noise), void 0 !== t.random && (this.random = t.random), void 0 !== t.size && (this.size = t.size), void 0 !== t.speed && (this.speed = r.setRangeValue(t.speed)), void 0 !== t.straight && (this.straight = t.straight), this.trail.load(t.trail), void 0 !== t.vibrate && (this.vibrate = t.vibrate), void 0 !== t.warp && (this.warp = t.warp) } } class mt { constructor() { this.enable = !1, this.area = 800, this.factor = 1e3 } get value_area() { return this.area } set value_area(t) { this.area = t } load(t) { var e; if (void 0 === t) return; void 0 !== t.enable && (this.enable = t.enable); const i = null !== (e = t.area) && void 0 !== e ? e : t.value_area; void 0 !== i && (this.area = i), void 0 !== t.factor && (this.factor = t.factor) } } class wt { constructor() { this.density = new mt, this.limit = 0, this.value = 100 } get max() { return this.limit } set max(t) { this.limit = t } load(t) { var e; if (void 0 === t) return; this.density.load(t.density); const i = null !== (e = t.limit) && void 0 !== e ? e : t.max; void 0 !== i && (this.limit = i), void 0 !== t.value && (this.value = t.value) } } class St { constructor() { this.count = 0, this.enable = !1, this.speed = 1, this.sync = !1 } load(t) { t && (void 0 !== t.count && (this.count = t.count), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.sync && (this.sync = t.sync)) } } class bt extends St { constructor() { super(), this.destroy = y.none, this.enable = !1, this.minimumValue = 0, this.speed = 2, this.startValue = w.random, this.sync = !1 } get opacity_min() { return this.minimumValue } set opacity_min(t) { this.minimumValue = t } load(t) { var e; if (void 0 === t) return; super.load(t), void 0 !== t.destroy && (this.destroy = t.destroy), void 0 !== t.enable && (this.enable = t.enable); const i = null !== (e = t.minimumValue) && void 0 !== e ? e : t.opacity_min; void 0 !== i && (this.minimumValue = i), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.startValue && (this.startValue = t.startValue), void 0 !== t.sync && (this.sync = t.sync) } } class Pt extends dt { constructor() { super(), this.animation = new bt, this.random.minimumValue = .1, this.value = 1 } get anim() { return this.animation } set anim(t) { this.animation = t } load(t) { var e; if (!t) return; super.load(t); const i = null !== (e = t.animation) && void 0 !== e ? e : t.anim; void 0 !== i && (this.animation.load(i), this.value = r.setRangeValue(this.value, this.animation.enable ? this.animation.minimumValue : void 0)) } } class _t { constructor() { this.options = {}, this.type = m.circle } get image() { var t; return null !== (t = this.options[m.image]) && void 0 !== t ? t : this.options[m.images] } set image(t) { this.options[m.image] = t, this.options[m.images] = t } get custom() { return this.options } set custom(t) { this.options = t } get images() { return this.image instanceof Array ? this.image : [this.image] } set images(t) { this.image = t } get stroke() { return [] } set stroke(t) { } get character() { var t; return null !== (t = this.options[m.character]) && void 0 !== t ? t : this.options[m.char] } set character(t) { this.options[m.character] = t, this.options[m.char] = t } get polygon() { var t; return null !== (t = this.options[m.polygon]) && void 0 !== t ? t : this.options[m.star] } set polygon(t) { this.options[m.polygon] = t, this.options[m.star] = t } load(t) { var e, i, o; if (void 0 === t) return; const n = null !== (e = t.options) && void 0 !== e ? e : t.custom; if (void 0 !== n) for (const t in n) { const e = n[t]; void 0 !== e && (this.options[t] = A.deepExtend(null !== (i = this.options[t]) && void 0 !== i ? i : {}, e)) } this.loadShape(t.character, m.character, m.char, !0), this.loadShape(t.polygon, m.polygon, m.star, !1), this.loadShape(null !== (o = t.image) && void 0 !== o ? o : t.images, m.image, m.images, !0), void 0 !== t.type && (this.type = t.type) } loadShape(t, e, i, o) { var n, s, a, r; void 0 !== t && (t instanceof Array ? (this.options[e] instanceof Array || (this.options[e] = [], this.options[i] && !o || (this.options[i] = [])), this.options[e] = A.deepExtend(null !== (n = this.options[e]) && void 0 !== n ? n : [], t), this.options[i] && !o || (this.options[i] = A.deepExtend(null !== (s = this.options[i]) && void 0 !== s ? s : [], t))) : (this.options[e] instanceof Array && (this.options[e] = {}, this.options[i] && !o || (this.options[i] = {})), this.options[e] = A.deepExtend(null !== (a = this.options[e]) && void 0 !== a ? a : {}, t), this.options[i] && !o || (this.options[i] = A.deepExtend(null !== (r = this.options[i]) && void 0 !== r ? r : {}, t)))) } } class xt extends St { constructor() { super(), this.destroy = y.none, this.enable = !1, this.minimumValue = 0, this.speed = 5, this.startValue = w.random, this.sync = !1 } get size_min() { return this.minimumValue } set size_min(t) { this.minimumValue = t } load(t) { var e; if (void 0 === t) return; super.load(t), void 0 !== t.destroy && (this.destroy = t.destroy), void 0 !== t.enable && (this.enable = t.enable); const i = null !== (e = t.minimumValue) && void 0 !== e ? e : t.size_min; void 0 !== i && (this.minimumValue = i), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.startValue && (this.startValue = t.startValue), void 0 !== t.sync && (this.sync = t.sync) } } class At extends dt { constructor() { super(), this.animation = new xt, this.random.minimumValue = 1, this.value = 3 } get anim() { return this.animation } set anim(t) { this.animation = t } load(t) { var e; if (!t) return; super.load(t); const i = null !== (e = t.animation) && void 0 !== e ? e : t.anim; void 0 !== i && (this.animation.load(i), this.value = r.setRangeValue(this.value, this.animation.enable ? this.animation.minimumValue : void 0)) } } class Ct { constructor() { this.enable = !1, this.speed = 0, this.sync = !1 } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.sync && (this.sync = t.sync)) } } class Vt extends dt { constructor() { super(), this.animation = new Ct, this.direction = s.clockwise, this.path = !1, this.value = { min: 0, max: 360 } } load(t) { t && (super.load(t), void 0 !== t.direction && (this.direction = t.direction), this.animation.load(t.animation), void 0 !== t.path && (this.path = t.path)) } } class Gt { constructor() { this.blur = 0, this.color = new nt, this.enable = !1, this.offset = { x: 0, y: 0 }, this.color.value = "#000000" } load(t) { void 0 !== t && (void 0 !== t.blur && (this.blur = t.blur), this.color = nt.create(this.color, t.color), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.offset && (void 0 !== t.offset.x && (this.offset.x = t.offset.x), void 0 !== t.offset.y && (this.offset.y = t.offset.y))) } } class Rt { constructor() { this.count = 0, this.enable = !1, this.offset = 0, this.speed = 1, this.sync = !0 } load(t) { void 0 !== t && (void 0 !== t.count && (this.count = t.count), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.offset && (this.offset = r.setRangeValue(t.offset)), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.sync && (this.sync = t.sync)) } } class Tt { constructor() { this.h = new Rt, this.s = new Rt, this.l = new Rt } load(t) { t && (this.h.load(t.h), this.s.load(t.s), this.l.load(t.l)) } } class Ot extends nt { constructor() { super(), this.animation = new Tt } static create(t, e) { const i = null != t ? t : new Ot; return void 0 !== e && i.load("string" == typeof e ? { value: e } : e), i } load(t) { if (super.load(t), !t) return; const e = t.animation; void 0 !== e && (void 0 !== e.enable ? this.animation.h.load(e) : this.animation.load(t.animation)) } } class Et { constructor() { this.width = 0 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = Ot.create(this.color, t.color)), void 0 !== t.width && (this.width = t.width), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class kt extends dt { constructor() { super(), this.random.minimumValue = .1, this.value = 1 } } class Mt { constructor() { this.horizontal = new kt, this.vertical = new kt } load(t) { t && (this.horizontal.load(t.horizontal), this.vertical.load(t.vertical)) } } class Lt { constructor() { this.enable = !0, this.retries = 0 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.retries && (this.retries = t.retries)) } } class It { constructor() { this.bounce = new Mt, this.enable = !1, this.mode = d.bounce, this.overlap = new Lt } load(t) { void 0 !== t && (this.bounce.load(t.bounce), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode), this.overlap.load(t.overlap)) } } class zt { constructor() { this.enable = !1, this.frequency = .05, this.opacity = 1 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = nt.create(this.color, t.color)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.frequency && (this.frequency = t.frequency), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class Ht { constructor() { this.lines = new zt, this.particles = new zt } load(t) { void 0 !== t && (this.lines.load(t.lines), this.particles.load(t.particles)) } } class Dt extends dt { constructor() { super(), this.sync = !1 } load(t) { t && (super.load(t), void 0 !== t.sync && (this.sync = t.sync)) } } class Ft extends dt { constructor() { super(), this.random.minimumValue = 1e-4, this.sync = !1 } load(t) { void 0 !== t && (super.load(t), void 0 !== t.sync && (this.sync = t.sync)) } } class Nt { constructor() { this.count = 0, this.delay = new Dt, this.duration = new Ft } load(t) { void 0 !== t && (void 0 !== t.count && (this.count = t.count), this.delay.load(t.delay), this.duration.load(t.duration)) } } class Bt { constructor() { this.bounce = new Mt, this.collisions = new It, this.color = new Ot, this.life = new Nt, this.links = new rt, this.move = new ft, this.number = new wt, this.opacity = new Pt, this.reduceDuplicates = !1, this.rotate = new Vt, this.shadow = new Gt, this.shape = new _t, this.size = new At, this.stroke = new Et, this.twinkle = new Ht } get line_linked() { return this.links } set line_linked(t) { this.links = t } get lineLinked() { return this.links } set lineLinked(t) { this.links = t } load(t) { var e, i, o, n, s, a, r; if (void 0 === t) return; this.bounce.load(t.bounce), this.color = Ot.create(this.color, t.color), this.life.load(t.life); const c = null !== (i = null !== (e = t.links) && void 0 !== e ? e : t.lineLinked) && void 0 !== i ? i : t.line_linked; void 0 !== c && this.links.load(c), this.move.load(t.move), this.number.load(t.number), this.opacity.load(t.opacity), void 0 !== t.reduceDuplicates && (this.reduceDuplicates = t.reduceDuplicates), this.rotate.load(t.rotate), this.shape.load(t.shape), this.size.load(t.size), this.shadow.load(t.shadow), this.twinkle.load(t.twinkle); const l = null !== (n = null === (o = t.move) || void 0 === o ? void 0 : o.collisions) && void 0 !== n ? n : null === (s = t.move) || void 0 === s ? void 0 : s.bounce; void 0 !== l && (this.collisions.enable = l), this.collisions.load(t.collisions); const h = null !== (a = t.stroke) && void 0 !== a ? a : null === (r = t.shape) || void 0 === r ? void 0 : r.stroke; void 0 !== h && (h instanceof Array ? this.stroke = h.map(t => { const e = new Et; return e.load(t), e }) : (this.stroke instanceof Array && (this.stroke = new Et), this.stroke.load(h))) } } class jt { constructor(t) { this.container = t } startInfection(t) { t > this.container.actualOptions.infection.stages.length || t < 0 || (this.infectionDelay = 0, this.infectionDelayStage = t) } updateInfectionStage(t) { t > this.container.actualOptions.infection.stages.length || t < 0 || void 0 !== this.infectionStage && this.infectionStage > t || (this.infectionStage = t, this.infectionTime = 0) } updateInfection(t) { const e = this.container.actualOptions, i = e.infection, o = e.infection.stages, n = o.length; if (void 0 !== this.infectionDelay && void 0 !== this.infectionDelayStage) { const e = this.infectionDelayStage; if (e > n || e < 0) return; this.infectionDelay > 1e3 * i.delay ? (this.infectionStage = e, this.infectionTime = 0, delete this.infectionDelay, delete this.infectionDelayStage) : this.infectionDelay += t } else delete this.infectionDelay, delete this.infectionDelayStage; if (void 0 !== this.infectionStage && void 0 !== this.infectionTime) { const e = o[this.infectionStage]; void 0 !== e.duration && e.duration >= 0 && this.infectionTime > 1e3 * e.duration ? this.nextInfectionStage() : this.infectionTime += t } else delete this.infectionStage, delete this.infectionTime } nextInfectionStage() { const t = this.container.actualOptions, e = t.infection.stages.length; if (!(e <= 0 || void 0 === this.infectionStage) && (this.infectionTime = 0, e <= ++this.infectionStage)) { if (t.infection.cure) return delete this.infectionStage, void delete this.infectionTime; this.infectionStage = 0, this.infectionTime = 0 } } } class qt { constructor(t, e) { this.container = t, this.particle = e } move(t) { const e = this.particle; e.bubble.inRange = !1, e.links = []; for (const [, i] of this.container.plugins) { if (e.destroyed) break; i.particleUpdate && i.particleUpdate(e, t) } e.destroyed || (this.moveParticle(t), this.moveParallax()) } moveParticle(t) { var e, i; const o = this.particle, n = o.options; if (!n.move.enable) return; const s = this.container, a = this.getProximitySpeedFactor(), c = (null !== (e = o.moveSpeed) && void 0 !== e ? e : r.getRangeValue(o.options.move.speed) * s.retina.pixelRatio) * s.retina.reduceFactor, l = r.getRangeMax(o.options.size.value) * s.retina.pixelRatio, h = c / 2 * (n.move.size ? o.getRadius() / l : 1) * a * t.factor, d = null !== (i = o.moveDrift) && void 0 !== i ? i : r.getRangeValue(o.options.move.drift) * s.retina.pixelRatio; this.applyPath(t); const u = n.move.gravity; u.enable && (o.velocity.y += u.acceleration * t.factor / (60 * h)), o.velocity.x += d * t.factor / (60 * h); const p = 1 - o.options.move.decay; o.velocity.multTo(p); const v = o.velocity.mult(h); u.enable && v.y >= u.maxSpeed && u.maxSpeed > 0 && (v.y = u.maxSpeed, o.velocity.y = v.y / h), o.position.addTo(v), n.move.vibrate && (o.position.x += Math.sin(o.position.x * Math.cos(o.position.y)), o.position.y += Math.cos(o.position.y * Math.sin(o.position.x))); const g = o.initialPosition, y = r.getDistance(g, o.position); o.maxDistance && (y >= o.maxDistance && !o.misplaced ? (o.misplaced = y > o.maxDistance, o.velocity.x = o.velocity.y / 2 - o.velocity.x, o.velocity.y = o.velocity.x / 2 - o.velocity.y) : y < o.maxDistance && o.misplaced ? o.misplaced = !1 : o.misplaced && ((o.position.x < g.x && o.velocity.x < 0 || o.position.x > g.x && o.velocity.x > 0) && (o.velocity.x *= -Math.random()), (o.position.y < g.y && o.velocity.y < 0 || o.position.y > g.y && o.velocity.y > 0) && (o.velocity.y *= -Math.random()))) } applyPath(t) { const e = this.particle, i = e.options.move.path; if (!i.enable) return; const o = this.container; if (e.lastPathTime <= e.pathDelay) return void (e.lastPathTime += t.value); let n = o.pathGenerator; if (i.generator) { const t = B.getPathGenerator(i.generator); t && (n = t) } const s = n.generate(e); e.velocity.addTo(s), i.clamp && (e.velocity.x = r.clamp(e.velocity.x, -1, 1), e.velocity.y = r.clamp(e.velocity.y, -1, 1)), e.lastPathTime -= e.pathDelay } moveParallax() { const t = this.container, e = t.actualOptions; if (A.isSsr() || !e.interactivity.events.onHover.parallax.enable) return; const i = this.particle, o = e.interactivity.events.onHover.parallax.force, n = t.interactivity.mouse.position; if (!n) return; const s = t.canvas.size.width / 2, a = t.canvas.size.height / 2, r = e.interactivity.events.onHover.parallax.smooth, c = i.getRadius() / o, l = (n.x - s) * c, h = (n.y - a) * c; i.offset.x += (l - i.offset.x) / r, i.offset.y += (h - i.offset.y) / r } getProximitySpeedFactor() { const t = this.container, e = t.actualOptions; if (!A.isInArray(h.slow, e.interactivity.events.onHover.mode)) return 1; const i = this.container.interactivity.mouse.position; if (!i) return 1; const o = this.particle.getPosition(), n = r.getDistance(i, o), s = t.retina.slowModeRadius; return n > s ? 1 : (n / s || 0) / e.interactivity.modes.slow.factor } } class Ut { constructor(t, e, i, o) { var n, c, l, h, d, u, p, v, y; this.id = t, this.container = e, this.links = [], this.fill = !0, this.close = !0, this.lastPathTime = 0, this.destroyed = !1, this.misplaced = !1, this.loops = { opacity: 0, size: 0 }; const f = e.retina.pixelRatio, m = e.actualOptions, S = new Bt; S.load(m.particles); const b = S.shape.type, P = S.reduceDuplicates; if (this.shape = b instanceof Array ? A.itemFromArray(b, this.id, P) : b, null == o ? void 0 : o.shape) { if (o.shape.type) { const t = o.shape.type; this.shape = t instanceof Array ? A.itemFromArray(t, this.id, P) : t } const t = new _t; if (t.load(o.shape), this.shape) { const e = t.options[this.shape]; e && (this.shapeData = A.deepExtend({}, e instanceof Array ? A.itemFromArray(e, this.id, P) : e)) } } else { const t = S.shape.options[this.shape]; t && (this.shapeData = A.deepExtend({}, t instanceof Array ? A.itemFromArray(t, this.id, P) : t)) } void 0 !== o && S.load(o), void 0 !== (null === (n = this.shapeData) || void 0 === n ? void 0 : n.particles) && S.load(null === (c = this.shapeData) || void 0 === c ? void 0 : c.particles), this.fill = null !== (h = null === (l = this.shapeData) || void 0 === l ? void 0 : l.fill) && void 0 !== h ? h : this.fill, this.close = null !== (u = null === (d = this.shapeData) || void 0 === d ? void 0 : d.close) && void 0 !== u ? u : this.close, this.options = S, this.pathDelay = 1e3 * r.getValue(this.options.move.path.delay), e.retina.initParticle(this); const _ = this.options.color, x = this.options.size, C = r.getValue(x) * e.retina.pixelRatio, V = "boolean" == typeof x.random ? x.random : x.random.enable; this.size = { value: C }, this.direction = this.options.move.direction, this.bubble = { inRange: !1 }, this.initialVelocity = this.calculateVelocity(), this.velocity = this.initialVelocity.copy(); const G = this.options.rotate; this.rotate = { value: r.getRangeValue(G.value) * Math.PI / 180 }; let T = G.direction; if (T === s.random) { T = Math.floor(2 * Math.random()) > 0 ? s.counterClockwise : s.clockwise } switch (T) { case s.counterClockwise: case "counterClockwise": this.rotate.status = g.decreasing; break; case s.clockwise: this.rotate.status = g.increasing }const O = this.options.rotate.animation; O.enable && (this.rotate.velocity = O.speed / 360 * e.retina.reduceFactor, O.sync || (this.rotate.velocity *= Math.random())); const E = this.options.size.animation; if (E.enable) { if (this.size.status = g.increasing, !V) switch (E.startValue) { case w.min: this.size.value = E.minimumValue * f; break; case w.random: this.size.value = r.randomInRange(r.setRangeValue(E.minimumValue * f, this.size.value)); break; case w.max: default: this.size.status = g.decreasing }this.size.velocity = (null !== (p = this.sizeAnimationSpeed) && void 0 !== p ? p : e.retina.sizeAnimationSpeed) / 100 * e.retina.reduceFactor, E.sync || (this.size.velocity *= Math.random()) } const k = R.colorToHsl(_, this.id, P); if (k) { this.color = { h: { value: k.h }, s: { value: k.s }, l: { value: k.l } }; const t = this.options.color.animation; this.setColorAnimation(t.h, this.color.h), this.setColorAnimation(t.s, this.color.s), this.setColorAnimation(t.l, this.color.l) } this.position = this.calcPosition(this.container, i), this.initialPosition = this.position.copy(), this.offset = a.create(0, 0); const M = this.options.opacity, L = "boolean" == typeof M.random ? M.random : M.random.enable; this.opacity = { value: r.getValue(M) }; const I = M.animation; if (I.enable) { if (this.opacity.status = g.increasing, !L) switch (I.startValue) { case w.min: this.opacity.value = I.minimumValue; break; case w.random: this.opacity.value = r.randomInRange(r.setRangeValue(I.minimumValue, this.opacity.value)); break; case w.max: default: this.opacity.status = g.decreasing }this.opacity.velocity = I.speed / 100 * e.retina.reduceFactor, I.sync || (this.opacity.velocity *= Math.random()) } this.sides = 24; let z = e.drawers.get(this.shape); z || (z = B.getShapeDrawer(this.shape)) && e.drawers.set(this.shape, z); const H = null == z ? void 0 : z.getSidesCount; H && (this.sides = H(this)); const D = this.loadImageShape(e, z); D && (this.image = D.image, this.fill = D.fill, this.close = D.close), this.stroke = this.options.stroke instanceof Array ? A.itemFromArray(this.options.stroke, this.id, P) : this.options.stroke, this.strokeWidth = this.stroke.width * e.retina.pixelRatio; const F = null !== (v = R.colorToHsl(this.stroke.color)) && void 0 !== v ? v : this.getFillColor(); if (F) { this.strokeColor = { h: { value: F.h }, s: { value: F.s }, l: { value: F.l } }; const t = null === (y = this.stroke.color) || void 0 === y ? void 0 : y.animation; t && this.strokeColor && (this.setColorAnimation(t.h, this.strokeColor.h), this.setColorAnimation(t.s, this.strokeColor.s), this.setColorAnimation(t.l, this.strokeColor.l)) } const N = S.life; this.lifeDelay = e.retina.reduceFactor ? r.getValue(N.delay) * (N.delay.sync ? 1 : Math.random()) / e.retina.reduceFactor * 1e3 : 0, this.lifeDelayTime = 0, this.lifeDuration = e.retina.reduceFactor ? r.getValue(N.duration) * (N.duration.sync ? 1 : Math.random()) / e.retina.reduceFactor * 1e3 : 0, this.lifeTime = 0, this.livesRemaining = S.life.count, this.spawning = this.lifeDelay > 0, this.lifeDuration <= 0 && (this.lifeDuration = -1), this.livesRemaining <= 0 && (this.livesRemaining = -1), this.shadowColor = R.colorToRgb(this.options.shadow.color), this.updater = new ot(e, this), this.infecter = new jt(e), this.mover = new qt(e, this) } move(t) { this.mover.move(t) } update(t) { this.updater.update(t) } draw(t) { this.container.canvas.drawParticle(this, t) } getPosition() { return this.position.add(this.offset) } getRadius() { return this.bubble.radius || this.size.value } getMass() { const t = this.getRadius(); return Math.pow(t, 2) * Math.PI / 2 } getFillColor() { var t; return null !== (t = this.bubble.color) && void 0 !== t ? t : R.getHslFromAnimation(this.color) } getStrokeColor() { var t, e; return null !== (e = null !== (t = this.bubble.color) && void 0 !== t ? t : R.getHslFromAnimation(this.strokeColor)) && void 0 !== e ? e : this.getFillColor() } destroy() { this.destroyed = !0, this.bubble.inRange = !1, this.links = [] } reset() { this.loops.opacity = 0, this.loops.size = 0 } setColorAnimation(t, e) { if (t.enable) { if (e.velocity = t.speed / 100 * this.container.retina.reduceFactor, t.sync) return; e.status = g.increasing, e.velocity *= Math.random(), e.value && (e.value *= Math.random()) } else e.velocity = 0 } calcPosition(t, e, i = 0) { var o, n; for (const [, i] of t.plugins) { const t = void 0 !== i.particlePosition ? i.particlePosition(e, this) : void 0; if (void 0 !== t) return a.create(t.x, t.y) } const s = a.create(null !== (o = null == e ? void 0 : e.x) && void 0 !== o ? o : Math.random() * t.canvas.size.width, null !== (n = null == e ? void 0 : e.y) && void 0 !== n ? n : Math.random() * t.canvas.size.height), r = this.options.move.outMode; return (A.isInArray(r, u.bounce) || A.isInArray(r, u.bounceHorizontal)) && (s.x > t.canvas.size.width - 2 * this.size.value ? s.x -= this.size.value : s.x < 2 * this.size.value && (s.x += this.size.value)), (A.isInArray(r, u.bounce) || A.isInArray(r, u.bounceVertical)) && (s.y > t.canvas.size.height - 2 * this.size.value ? s.y -= this.size.value : s.y < 2 * this.size.value && (s.y += this.size.value)), this.checkOverlap(s, i) ? this.calcPosition(t, void 0, i + 1) : s } checkOverlap(t, e = 0) { const i = this.options.collisions.overlap; if (!i.enable) { const o = i.retries; if (o >= 0 && e > o) throw new Error("Particle is overlapping and can't be placed"); let n = !1; for (const e of this.container.particles.array) if (r.getDistance(t, e.position) < this.size.value + e.size.value) { n = !0; break } return n } return !1 } calculateVelocity() { const t = r.getParticleBaseVelocity(this.direction).copy(), e = this.options.move; let i, o = Math.PI / 4; "number" == typeof e.angle ? i = Math.PI / 180 * e.angle : (i = Math.PI / 180 * e.angle.value, o = Math.PI / 180 * e.angle.offset); const n = { left: Math.sin(o + i / 2) - Math.sin(o - i / 2), right: Math.cos(o + i / 2) - Math.cos(o - i / 2) }; return e.straight && !e.random || (t.x += r.randomInRange(r.setRangeValue(n.left, n.right)) / 2, t.y += r.randomInRange(r.setRangeValue(n.left, n.right)) / 2), t } loadImageShape(t, e) { var i, o, n, s, a; if (this.shape !== m.image && this.shape !== m.images) return; const r = e.getImages(t).images, c = this.shapeData, l = null !== (i = r.find(t => t.source === c.src)) && void 0 !== i ? i : r[0], h = this.getFillColor(); let d; if (!l) return; if (void 0 !== l.svgData && c.replaceColor && h) { const t = R.replaceColorSvg(l, h, this.opacity.value), e = new Blob([t], { type: "image/svg+xml" }), i = URL || window.URL || window.webkitURL || window, n = i.createObjectURL(e), s = new Image; d = { data: l, loaded: !1, ratio: c.width / c.height, replaceColor: null !== (o = c.replaceColor) && void 0 !== o ? o : c.replace_color, source: c.src }, s.addEventListener("load", () => { this.image && (this.image.loaded = !0, l.element = s), i.revokeObjectURL(n) }), s.addEventListener("error", () => { i.revokeObjectURL(n), A.loadImage(c.src).then(t => { this.image && t && (l.element = t.element, this.image.loaded = !0) }) }), s.src = n } else d = { data: l, loaded: !0, ratio: c.width / c.height, replaceColor: null !== (n = c.replaceColor) && void 0 !== n ? n : c.replace_color, source: c.src }; return d.ratio || (d.ratio = 1), { image: d, fill: null !== (s = c.fill) && void 0 !== s ? s : this.fill, close: null !== (a = c.close) && void 0 !== a ? a : this.close } } } class Qt { constructor(t) { this.container = t } isEnabled() { const t = this.container, e = t.interactivity.mouse, i = t.actualOptions.interactivity.events; if (!i.onHover.enable || !e.position) return !1; const o = i.onHover.mode; return A.isInArray(h.grab, o) } reset() { } interact() { var t; const e = this.container, i = e.actualOptions.interactivity; if (i.events.onHover.enable && e.interactivity.status === C.mouseMoveEvent) { const o = e.interactivity.mouse.position; if (void 0 === o) return; const n = e.retina.grabModeDistance, s = e.particles.quadTree.queryCircle(o, n); for (const a of s) { const s = a.getPosition(), c = r.getDistance(s, o); if (c <= n) { const s = i.modes.grab.links, r = s.opacity, l = r - c * r / n; if (l > 0) { const i = null !== (t = s.color) && void 0 !== t ? t : a.options.links.color; if (!e.particles.grabLineColor) { const t = e.actualOptions.interactivity.modes.grab.links; e.particles.grabLineColor = R.getLinkRandomColor(i, t.blink, t.consent) } const n = R.getLinkColor(a, void 0, e.particles.grabLineColor); if (void 0 === n) return; e.canvas.drawGrabLine(a, n, l, o) } } } } } } class Wt { constructor(t) { this.container = t } isEnabled() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse, o = e.interactivity.events, n = o.onDiv, s = A.isDivModeEnabled(l.repulse, n); if (!(s || o.onHover.enable && i.position || o.onClick.enable && i.clickPosition)) return !1; const a = o.onHover.mode, r = o.onClick.mode; return A.isInArray(h.repulse, a) || A.isInArray(c.repulse, r) || s } reset() { } interact() { const t = this.container, e = t.actualOptions, i = t.interactivity.status === C.mouseMoveEvent, o = e.interactivity.events, n = o.onHover.enable, s = o.onHover.mode, a = o.onClick.enable, r = o.onClick.mode, d = o.onDiv; i && n && A.isInArray(h.repulse, s) ? this.hoverRepulse() : a && A.isInArray(c.repulse, r) ? this.clickRepulse() : A.divModeExecute(l.repulse, d, (t, e) => this.singleSelectorRepulse(t, e)) } singleSelectorRepulse(t, e) { const i = this.container, o = document.querySelectorAll(t); o.length && o.forEach(t => { const o = t, n = i.retina.pixelRatio, s = { x: (o.offsetLeft + o.offsetWidth / 2) * n, y: (o.offsetTop + o.offsetHeight / 2) * n }, a = o.offsetWidth / 2 * n, r = e.type === S.circle ? new k(s.x, s.y, a) : new M(o.offsetLeft * n, o.offsetTop * n, o.offsetWidth * n, o.offsetHeight * n), c = i.actualOptions.interactivity.modes.repulse.divs, l = A.divMode(c, o); this.processRepulse(s, a, r, l) }) } hoverRepulse() { const t = this.container, e = t.interactivity.mouse.position; if (!e) return; const i = t.retina.repulseModeDistance; this.processRepulse(e, i, new k(e.x, e.y, i)) } processRepulse(t, e, i, o) { var n; const s = this.container, a = s.particles.quadTree.query(i); for (const i of a) { const { dx: a, dy: c, distance: l } = r.getDistances(i.position, t), h = { x: a / l, y: c / l }, d = 100 * (null !== (n = null == o ? void 0 : o.speed) && void 0 !== n ? n : s.actualOptions.interactivity.modes.repulse.speed), u = r.clamp((1 - Math.pow(l / e, 2)) * d, 0, 50); i.position.x += h.x * u, i.position.y += h.y * u } } clickRepulse() { const t = this.container; if (t.repulse.finish || (t.repulse.count || (t.repulse.count = 0), t.repulse.count++, t.repulse.count === t.particles.count && (t.repulse.finish = !0)), t.repulse.clicking) { const e = t.retina.repulseModeDistance, i = Math.pow(e / 6, 3), o = t.interactivity.mouse.clickPosition; if (void 0 === o) return; const n = new k(o.x, o.y, i), s = t.particles.quadTree.query(n); for (const e of s) { const { dx: n, dy: s, distance: c } = r.getDistances(o, e.position), l = c * c; if (l <= i) { t.repulse.particles.push(e); const o = t.actualOptions.interactivity.modes.repulse.speed, r = a.create(n, s); r.length = -i * o / l, e.velocity.setTo(r) } } } else if (!1 === t.repulse.clicking) { for (const e of t.repulse.particles) e.velocity.setTo(e.initialVelocity); t.repulse.particles = [] } } } function $t(t, e, i, o) { if (e > i) { const n = t + (e - i) * o; return r.clamp(n, t, e) } if (e < i) { const n = t - (i - e) * o; return r.clamp(n, e, t) } } class Xt { constructor(t) { this.container = t } isEnabled() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse, o = e.interactivity.events, n = o.onDiv, s = A.isDivModeEnabled(l.bubble, n); if (!(s || o.onHover.enable && i.position || o.onClick.enable && i.clickPosition)) return !1; const a = o.onHover.mode, r = o.onClick.mode; return A.isInArray(h.bubble, a) || A.isInArray(c.bubble, r) || s } reset(t, e) { t.bubble.inRange && !e || (delete t.bubble.div, delete t.bubble.opacity, delete t.bubble.radius, delete t.bubble.color) } interact() { const t = this.container.actualOptions.interactivity.events, e = t.onHover, i = t.onClick, o = e.enable, n = e.mode, s = i.enable, a = i.mode, r = t.onDiv; o && A.isInArray(h.bubble, n) ? this.hoverBubble() : s && A.isInArray(c.bubble, a) ? this.clickBubble() : A.divModeExecute(l.bubble, r, (t, e) => this.singleSelectorHover(t, e)) } singleSelectorHover(t, e) { const i = this.container, o = document.querySelectorAll(t); o.length && o.forEach(t => { const o = t, n = i.retina.pixelRatio, s = { x: (o.offsetLeft + o.offsetWidth / 2) * n, y: (o.offsetTop + o.offsetHeight / 2) * n }, a = o.offsetWidth / 2 * n, r = e.type === S.circle ? new k(s.x, s.y, a) : new M(o.offsetLeft * n, o.offsetTop * n, o.offsetWidth * n, o.offsetHeight * n), c = i.particles.quadTree.query(r); for (const t of c) { if (!r.contains(t.getPosition())) continue; t.bubble.inRange = !0; const e = i.actualOptions.interactivity.modes.bubble.divs, n = A.divMode(e, o); t.bubble.div && t.bubble.div === o || (this.reset(t, !0), t.bubble.div = o), this.hoverBubbleSize(t, 1, n), this.hoverBubbleOpacity(t, 1, n), this.hoverBubbleColor(t, n) } }) } process(t, e, i, o) { const n = this.container, s = o.bubbleObj.optValue; if (void 0 === s) return; const a = n.actualOptions.interactivity.modes.bubble.duration, r = n.retina.bubbleModeDistance, c = o.particlesObj.optValue, l = o.bubbleObj.value, h = o.particlesObj.value || 0, d = o.type; if (s !== c) if (n.bubble.durationEnd) l && (d === f.size && delete t.bubble.radius, d === f.opacity && delete t.bubble.opacity); else if (e <= r) { if ((null != l ? l : h) !== s) { const e = h - i * (h - s) / a; d === f.size && (t.bubble.radius = e), d === f.opacity && (t.bubble.opacity = e) } } else d === f.size && delete t.bubble.radius, d === f.opacity && delete t.bubble.opacity } clickBubble() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse.clickPosition; if (void 0 === i) return; const o = t.retina.bubbleModeDistance, n = t.particles.quadTree.queryCircle(i, o); for (const o of n) { if (!t.bubble.clicking) continue; o.bubble.inRange = !t.bubble.durationEnd; const n = o.getPosition(), s = r.getDistance(n, i), a = ((new Date).getTime() - (t.interactivity.mouse.clickTime || 0)) / 1e3; a > e.interactivity.modes.bubble.duration && (t.bubble.durationEnd = !0), a > 2 * e.interactivity.modes.bubble.duration && (t.bubble.clicking = !1, t.bubble.durationEnd = !1); const c = { bubbleObj: { optValue: t.retina.bubbleModeSize, value: o.bubble.radius }, particlesObj: { optValue: r.getRangeMax(o.options.size.value) * t.retina.pixelRatio, value: o.size.value }, type: f.size }; this.process(o, s, a, c); const l = { bubbleObj: { optValue: e.interactivity.modes.bubble.opacity, value: o.bubble.opacity }, particlesObj: { optValue: r.getRangeMax(o.options.opacity.value), value: o.opacity.value }, type: f.opacity }; this.process(o, s, a, l), t.bubble.durationEnd ? delete o.bubble.color : s <= t.retina.bubbleModeDistance ? this.hoverBubbleColor(o) : delete o.bubble.color } } hoverBubble() { const t = this.container, e = t.interactivity.mouse.position; if (void 0 === e) return; const i = t.retina.bubbleModeDistance, o = t.particles.quadTree.queryCircle(e, i); for (const n of o) { n.bubble.inRange = !0; const o = n.getPosition(), s = r.getDistance(o, e), a = 1 - s / i; s <= i ? a >= 0 && t.interactivity.status === C.mouseMoveEvent && (this.hoverBubbleSize(n, a), this.hoverBubbleOpacity(n, a), this.hoverBubbleColor(n)) : this.reset(n), t.interactivity.status === C.mouseLeaveEvent && this.reset(n) } } hoverBubbleSize(t, e, i) { const o = this.container, n = (null == i ? void 0 : i.size) ? i.size * o.retina.pixelRatio : o.retina.bubbleModeSize; if (void 0 === n) return; const s = r.getRangeMax(t.options.size.value) * o.retina.pixelRatio, a = $t(t.size.value, n, s, e); void 0 !== a && (t.bubble.radius = a) } hoverBubbleOpacity(t, e, i) { var o; const n = this.container.actualOptions, s = null !== (o = null == i ? void 0 : i.opacity) && void 0 !== o ? o : n.interactivity.modes.bubble.opacity; if (void 0 === s) return; const a = t.options.opacity.value, c = $t(t.opacity.value, s, r.getRangeMax(a), e); void 0 !== c && (t.bubble.opacity = c) } hoverBubbleColor(t, e) { var i; const o = this.container.actualOptions; if (void 0 === t.bubble.color) { const n = null !== (i = null == e ? void 0 : e.color) && void 0 !== i ? i : o.interactivity.modes.bubble.color; if (void 0 === n) return; const s = n instanceof Array ? A.itemFromArray(n) : n; t.bubble.color = R.colorToHsl(s) } } } class Yt { constructor(t) { this.container = t } isEnabled() { const t = this.container, e = t.interactivity.mouse, i = t.actualOptions.interactivity.events; if (!i.onHover.enable || !e.position) return !1; const o = i.onHover.mode; return A.isInArray(h.connect, o) } reset() { } interact() { const t = this.container; if (t.actualOptions.interactivity.events.onHover.enable && "mousemove" === t.interactivity.status) { const e = t.interactivity.mouse.position; if (!e) return; const i = Math.abs(t.retina.connectModeRadius), o = t.particles.quadTree.queryCircle(e, i); let n = 0; for (const e of o) { const i = e.getPosition(); for (const s of o.slice(n + 1)) { const o = s.getPosition(), n = Math.abs(t.retina.connectModeDistance), a = Math.abs(i.x - o.x), r = Math.abs(i.y - o.y); a < n && r < n && t.canvas.drawConnectLine(e, s) } ++n } } } } class Jt { constructor(t) { this.container = t } isEnabled(t) { return t.options.links.enable } reset() { } interact(t) { var e; const i = this.container, o = t.options.links, n = o.opacity, s = null !== (e = t.linksDistance) && void 0 !== e ? e : i.retina.linksDistance, a = i.canvas.size, c = o.warp, l = t.getPosition(), h = c ? new L(l.x, l.y, s, a) : new k(l.x, l.y, s), d = i.particles.quadTree.query(h); for (const e of d) { const h = e.options.links; if (t === e || !h.enable || o.id !== h.id || e.spawning || e.destroyed) continue; const d = e.getPosition(); let u = r.getDistance(l, d); if (c && u > s) { const t = { x: d.x - a.width, y: d.y }; if ((u = r.getDistance(l, t)) > s) { const t = { x: d.x - a.width, y: d.y - a.height }; if ((u = r.getDistance(l, t)) > s) { const t = { x: d.x, y: d.y - a.height }; u = r.getDistance(l, t) } } } if (u > s) return; const p = (1 - u / s) * n, v = t.options.links; let g = void 0 !== v.id ? i.particles.linksColors.get(v.id) : i.particles.linksColor; if (!g) { const t = v.color; g = R.getLinkRandomColor(t, v.blink, v.consent), void 0 !== v.id ? i.particles.linksColors.set(v.id, g) : i.particles.linksColor = g } -1 === e.links.map(t => t.destination).indexOf(t) && -1 === t.links.map(t => t.destination).indexOf(e) && t.links.push({ destination: e, opacity: p }) } } } class Zt { constructor(t) { this.container = t } interact(t) { var e; const i = this.container, o = null !== (e = t.linksDistance) && void 0 !== e ? e : i.retina.linksDistance, n = t.getPosition(), s = i.particles.quadTree.queryCircle(n, o); for (const e of s) { if (t === e || !e.options.move.attract.enable || e.destroyed || e.spawning) continue; const i = e.getPosition(), { dx: o, dy: s } = r.getDistances(n, i), a = t.options.move.attract.rotate, c = o / (1e3 * a.x), l = s / (1e3 * a.y); t.velocity.x -= c, t.velocity.y -= l, e.velocity.x += c, e.velocity.y += l } } isEnabled(t) { return t.options.move.attract.enable } reset() { } } class Kt { constructor(t) { this.container = t } isEnabled(t) { return t.options.collisions.enable } reset() { } interact(t) { const e = this.container, i = t.getPosition(), o = e.particles.quadTree.queryCircle(i, 2 * t.getRadius()); for (const e of o) { if (t === e || !e.options.collisions.enable || t.options.collisions.mode !== e.options.collisions.mode || e.destroyed || e.spawning) continue; const o = e.getPosition(); r.getDistance(i, o) <= t.getRadius() + e.getRadius() && this.resolveCollision(t, e) } } resolveCollision(t, e) { switch (t.options.collisions.mode) { case d.absorb: this.absorb(t, e); break; case d.bounce: !function (t, e) { A.circleBounce(A.circleBounceDataFromParticle(t), A.circleBounceDataFromParticle(e)) }(t, e); break; case d.destroy: !function (t, e) { void 0 === t.getRadius() && void 0 !== e.getRadius() ? t.destroy() : void 0 !== t.getRadius() && void 0 === e.getRadius() ? e.destroy() : void 0 !== t.getRadius() && void 0 !== e.getRadius() && (t.getRadius() >= e.getRadius() ? e.destroy() : t.destroy()) }(t, e) } } absorb(t, e) { const i = this.container, o = i.actualOptions.fpsLimit / 1e3; if (void 0 === t.getRadius() && void 0 !== e.getRadius()) t.destroy(); else if (void 0 !== t.getRadius() && void 0 === e.getRadius()) e.destroy(); else if (void 0 !== t.getRadius() && void 0 !== e.getRadius()) if (t.getRadius() >= e.getRadius()) { const n = r.clamp(t.getRadius() / e.getRadius(), 0, e.getRadius()) * o; t.size.value += n, e.size.value -= n, e.getRadius() <= i.retina.pixelRatio && (e.size.value = 0, e.destroy()) } else { const n = r.clamp(e.getRadius() / t.getRadius(), 0, t.getRadius()) * o; t.size.value -= n, e.size.value += n, t.getRadius() <= i.retina.pixelRatio && (t.size.value = 0, t.destroy()) } } } class te { constructor(t) { this.container = t } isEnabled() { return this.container.actualOptions.infection.enable } reset() { } interact(t, e) { var i, o; const n = t.infecter; if (n.updateInfection(e.value), void 0 === n.infectionStage) return; const s = this.container, a = s.actualOptions.infection; if (!a.enable || a.stages.length < 1) return; const r = a.stages[n.infectionStage], c = s.retina.pixelRatio, l = 2 * t.getRadius() + r.radius * c, h = t.getPosition(), d = null !== (i = r.infectedStage) && void 0 !== i ? i : n.infectionStage, u = s.particles.quadTree.queryCircle(h, l), p = r.rate, v = u.length; for (const e of u) { if (e === t || e.destroyed || e.spawning || void 0 !== e.infecter.infectionStage && e.infecter.infectionStage === n.infectionStage) continue; const i = e.infecter; if (Math.random() < p / v) if (void 0 === i.infectionStage) i.startInfection(d); else if (i.infectionStage < n.infectionStage) i.updateInfectionStage(d); else if (i.infectionStage > n.infectionStage) { const t = a.stages[i.infectionStage], e = null !== (o = null == t ? void 0 : t.infectedStage) && void 0 !== o ? o : i.infectionStage; n.updateInfectionStage(e) } } } } class ee { constructor(t) { this.container = t, this.delay = 0 } interact(t) { if (!this.container.retina.reduceFactor) return; const e = this.container, i = e.actualOptions.interactivity.modes.trail, o = 1e3 * i.delay / this.container.retina.reduceFactor; this.delay < o && (this.delay += t.value), this.delay >= o && (e.particles.push(i.quantity, e.interactivity.mouse, i.particles), this.delay -= o) } isEnabled() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse, o = e.interactivity.events; return i.clicking && i.inside && !!i.position && A.isInArray(c.trail, o.onClick.mode) || i.inside && !!i.position && A.isInArray(h.trail, o.onHover.mode) } reset() { } } class ie { constructor(t) { this.container = t } isEnabled() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse, o = e.interactivity.events; if (!(o.onHover.enable && i.position || o.onClick.enable && i.clickPosition)) return !1; const n = o.onHover.mode, s = o.onClick.mode; return A.isInArray(h.attract, n) || A.isInArray(c.attract, s) } reset() { } interact() { const t = this.container, e = t.actualOptions, i = t.interactivity.status === C.mouseMoveEvent, o = e.interactivity.events, n = o.onHover.enable, s = o.onHover.mode, a = o.onClick.enable, r = o.onClick.mode; i && n && A.isInArray(h.attract, s) ? this.hoverAttract() : a && A.isInArray(c.attract, r) && this.clickAttract() } hoverAttract() { const t = this.container, e = t.interactivity.mouse.position; if (!e) return; const i = t.retina.attractModeDistance; this.processAttract(e, i, new k(e.x, e.y, i)) } processAttract(t, e, i) { const o = this.container, n = o.particles.quadTree.query(i); for (const i of n) { const { dx: n, dy: s, distance: a } = r.getDistances(i.position, t), c = { x: n / a, y: s / a }, l = o.actualOptions.interactivity.modes.attract.speed, h = r.clamp((1 - Math.pow(a / e, 2)) * l, 0, 50); i.position.x -= c.x * h, i.position.y -= c.y * h } } clickAttract() { const t = this.container; if (t.attract.finish || (t.attract.count || (t.attract.count = 0), t.attract.count++, t.attract.count === t.particles.count && (t.attract.finish = !0)), t.attract.clicking) { const e = t.interactivity.mouse.clickPosition; if (!e) return; const i = t.retina.attractModeDistance; this.processAttract(e, i, new k(e.x, e.y, i)) } else !1 === t.attract.clicking && (t.attract.particles = []) } } class oe { constructor(t) { this.container = t } interact(t) { const e = this.container; if (e.actualOptions.interactivity.events.onHover.enable && "mousemove" === e.interactivity.status) { const i = this.container.interactivity.mouse.position; i && e.canvas.drawParticleShadow(t, i) } } isEnabled() { const t = this.container, e = t.interactivity.mouse, i = t.actualOptions.interactivity.events; if (!i.onHover.enable || !e.position) return !1; const o = i.onHover.mode; return A.isInArray(h.light, o) } reset() { } } class ne { constructor(t) { this.container = t } interact() { const t = this.container; if (t.actualOptions.interactivity.events.onHover.enable && "mousemove" === t.interactivity.status) { const e = t.interactivity.mouse.position; if (!e) return; t.canvas.drawLight(e) } } isEnabled() { const t = this.container, e = t.interactivity.mouse, i = t.actualOptions.interactivity.events; if (!i.onHover.enable || !e.position) return !1; const o = i.onHover.mode; return A.isInArray(h.light, o) } reset() { } } class se { constructor(t) { this.container = t } isEnabled() { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse, o = e.interactivity.events, n = o.onDiv; return i.position && o.onHover.enable && A.isInArray(h.bounce, o.onHover.mode) || A.isDivModeEnabled(l.bounce, n) } interact() { const t = this.container, e = t.actualOptions.interactivity.events, i = t.interactivity.status === C.mouseMoveEvent, o = e.onHover.enable, n = e.onHover.mode, s = e.onDiv; i && o && A.isInArray(h.bounce, n) ? this.processMouseBounce() : A.divModeExecute(l.bounce, s, (t, e) => this.singleSelectorBounce(t, e)) } reset() { } processMouseBounce() { const t = this.container, e = 10 * t.retina.pixelRatio, i = t.interactivity.mouse.position, o = t.retina.bounceModeDistance; i && this.processBounce(i, o, new k(i.x, i.y, o + e)) } singleSelectorBounce(t, e) { const i = this.container, o = document.querySelectorAll(t); o.length && o.forEach(t => { const o = t, n = i.retina.pixelRatio, s = { x: (o.offsetLeft + o.offsetWidth / 2) * n, y: (o.offsetTop + o.offsetHeight / 2) * n }, a = o.offsetWidth / 2 * n, r = 10 * n, c = e.type === S.circle ? new k(s.x, s.y, a + r) : new M(o.offsetLeft * n - r, o.offsetTop * n - r, o.offsetWidth * n + 2 * r, o.offsetHeight * n + 2 * r); this.processBounce(s, a, c) }) } processBounce(t, e, i) { const o = this.container.particles.quadTree.query(i); for (const n of o) i instanceof k ? A.circleBounce(A.circleBounceDataFromParticle(n), { position: t, radius: e, mass: Math.pow(e, 2) * Math.PI / 2, velocity: a.create(0, 0), factor: { horizontal: 0, vertical: 0 } }) : i instanceof M && A.rectBounce(n, A.calculateBounds(t, e)) } } class ae { constructor(t) { this.container = t, this.externalInteractors = [new se(t), new Xt(t), new Yt(t), new Qt(t), new ne(t), new ie(t), new Wt(t), new ee(t)], this.particleInteractors = [new Zt(t), new oe(t), new Kt(t), new te(t), new Jt(t)] } init() { } externalInteract(t) { for (const e of this.externalInteractors) e.isEnabled() && e.interact(t) } particlesInteract(t, e) { for (const e of this.externalInteractors) e.reset(t); for (const i of this.particleInteractors) i.isEnabled(t) && i.interact(t, e) } } class re { constructor(t) { this.container = t, this.nextId = 0, this.array = [], this.limit = 0, this.linksFreq = new Map, this.trianglesFreq = new Map, this.interactionManager = new ae(t); const e = this.container.canvas.size; this.linksColors = new Map, this.quadTree = new q(new M(-e.width / 4, -e.height / 4, 3 * e.width / 2, 3 * e.height / 2), 4) } get count() { return this.array.length } init() { const t = this.container, e = t.actualOptions; this.linksFreq = new Map, this.trianglesFreq = new Map; let i = !1; for (const i of e.manualParticles) { const e = i.position ? { x: i.position.x * t.canvas.size.width / 100, y: i.position.y * t.canvas.size.height / 100 } : void 0; this.addParticle(e, i.options) } for (const [, e] of t.plugins) if (void 0 !== e.particlesInitialization && (i = e.particlesInitialization()), i) break; if (!i) for (let t = this.count; t < e.particles.number.value; t++)this.addParticle(); if (e.infection.enable) for (let t = 0; t < e.infection.infections; t++) { const t = this.array.filter(t => void 0 === t.infecter.infectionStage); A.itemFromArray(t).infecter.startInfection(0) } this.interactionManager.init(), t.pathGenerator.init() } redraw() { this.clear(), this.init(), this.draw({ value: 0, factor: 0 }) } removeAt(t, e) { if (t >= 0 && t <= this.count) for (const i of this.array.splice(t, null != e ? e : 1)) i.destroy() } remove(t) { this.removeAt(this.array.indexOf(t)) } update(t) { const e = this.container, i = []; e.pathGenerator.update(); for (const [, i] of e.plugins) void 0 !== i.update && i.update(t); for (const e of this.array) { const o = this.container.canvas.resizeFactor; o && (e.position.x *= o.width, e.position.y *= o.height), e.move(t), e.destroyed ? i.push(e) : this.quadTree.insert(new j(e.getPosition(), e)) } for (const t of i) this.remove(t); this.interactionManager.externalInteract(t); for (const e of this.container.particles.array) e.update(t), e.destroyed || e.spawning || this.interactionManager.particlesInteract(e, t); delete e.canvas.resizeFactor } draw(t) { const e = this.container; e.canvas.clear(); const i = this.container.canvas.size; this.quadTree = new q(new M(-i.width / 4, -i.height / 4, 3 * i.width / 2, 3 * i.height / 2), 4), this.update(t); for (const [, i] of e.plugins) e.canvas.drawPlugin(i, t); for (const e of this.array) e.draw(t) } clear() { this.array = [] } push(t, e, i) { const o = this.container, n = o.actualOptions.particles.number.limit * o.density; if (this.pushing = !0, n > 0) { const e = this.count + t - n; e > 0 && this.removeQuantity(e) } for (let o = 0; o < t; o++)this.addParticle(null == e ? void 0 : e.position, i); this.pushing = !1 } addParticle(t, e) { try { const i = new Ut(this.nextId, this.container, t, e); return this.array.push(i), this.nextId++, i } catch (t) { return void console.warn("error adding particle") } } removeQuantity(t) { this.removeAt(0, t) } getLinkFrequency(t, e) { const i = `${Math.min(t.id, e.id)}_${Math.max(t.id, e.id)}`; let o = this.linksFreq.get(i); return void 0 === o && (o = Math.random(), this.linksFreq.set(i, o)), o } getTriangleFrequency(t, e, i) { let [o, n, s] = [t.id, e.id, i.id]; o > n && ([n, o] = [o, n]), n > s && ([s, n] = [n, s]), o > s && ([s, o] = [o, s]); const a = `${o}_${n}_${s}`; let r = this.trianglesFreq.get(a); return void 0 === r && (r = Math.random(), this.trianglesFreq.set(a, r)), r } setDensity() { const t = this.container.actualOptions; this.applyDensity(t.particles) } applyDensity(t) { var e; if (!(null === (e = t.number.density) || void 0 === e ? void 0 : e.enable)) return; const i = t.number, o = this.initDensityFactor(i.density), n = i.value, s = i.limit > 0 ? i.limit : n, a = Math.min(n, s) * o, r = this.count; this.limit = i.limit * o, r < a ? this.push(Math.abs(a - r), void 0, t) : r > a && this.removeQuantity(r - a) } initDensityFactor(t) { const e = this.container; if (!e.canvas.element || !t.enable) return 1; const i = e.canvas.element, o = e.retina.pixelRatio; return i.width * i.height / (t.factor * o * o * t.area) } } class ce { constructor(t) { this.container = t } init() { const t = this.container, e = t.actualOptions; e.detectRetina ? this.pixelRatio = A.isSsr() ? 1 : window.devicePixelRatio : this.pixelRatio = 1; const i = this.container.actualOptions.motion; if (i && (i.disable || i.reduce.value)) if (A.isSsr() || "undefined" == typeof matchMedia || !matchMedia) this.reduceFactor = 1; else { const e = matchMedia("(prefers-reduced-motion: reduce)"); if (e) { this.handleMotionChange(e); const i = () => { this.handleMotionChange(e), t.refresh().catch(() => { }) }; void 0 !== e.addEventListener ? e.addEventListener("change", i) : void 0 !== e.addListener && e.addListener(i) } } else this.reduceFactor = 1; const o = this.pixelRatio; if (t.canvas.element) { const e = t.canvas.element; t.canvas.size.width = e.offsetWidth * o, t.canvas.size.height = e.offsetHeight * o } const n = e.particles; this.linksDistance = n.links.distance * o, this.linksWidth = n.links.width * o, this.sizeAnimationSpeed = n.size.animation.speed * o; const s = e.interactivity.modes; this.connectModeDistance = s.connect.distance * o, this.connectModeRadius = s.connect.radius * o, this.grabModeDistance = s.grab.distance * o, this.repulseModeDistance = s.repulse.distance * o, this.bounceModeDistance = s.bounce.distance * o, this.attractModeDistance = s.attract.distance * o, this.slowModeRadius = s.slow.radius * o, this.bubbleModeDistance = s.bubble.distance * o, s.bubble.size && (this.bubbleModeSize = s.bubble.size * o) } initParticle(t) { const e = t.options, i = this.pixelRatio; t.linksDistance = e.links.distance * i, t.linksWidth = e.links.width * i, t.moveDrift = r.getRangeValue(e.move.drift) * i, t.moveSpeed = r.getRangeValue(e.move.speed) * i, t.sizeAnimationSpeed = e.size.animation.speed * i, t.maxDistance = e.move.distance * i } handleMotionChange(t) { const e = this.container.actualOptions; if (t.matches) { const t = e.motion; this.reduceFactor = t.disable ? 0 : t.reduce.value ? 1 / t.reduce.factor : 1 } else this.reduceFactor = 1 } } class le { constructor(t) { this.container = t } nextFrame(t) { try { const e = this.container; if (void 0 !== e.lastFrameTime && t < e.lastFrameTime + 1e3 / e.fpsLimit) return void e.draw(); const i = t - e.lastFrameTime, o = { value: i, factor: 60 * i / 1e3 }; e.lastFrameTime = t, e.particles.draw(o), e.getAnimationStatus() && e.draw() } catch (t) { console.error("tsParticles error in animation loop", t) } } } class he { constructor() { this.enable = !1, this.mode = [] } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode)) } } class de { constructor() { this.selectors = [], this.enable = !1, this.mode = [], this.type = S.circle } get elementId() { return this.ids } set elementId(t) { this.ids = t } get el() { return this.elementId } set el(t) { this.elementId = t } get ids() { return this.selectors instanceof Array ? this.selectors.map(t => t.replace("#", "")) : this.selectors.replace("#", "") } set ids(t) { t instanceof Array ? this.selectors = t.map(t => `#${t}`) : this.selectors = `#${t}` } load(t) { var e, i; if (void 0 === t) return; const o = null !== (i = null !== (e = t.ids) && void 0 !== e ? e : t.elementId) && void 0 !== i ? i : t.el; void 0 !== o && (this.ids = o), void 0 !== t.selectors && (this.selectors = t.selectors), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.type && (this.type = t.type) } } class ue { constructor() { this.enable = !1, this.force = 2, this.smooth = 10 } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.force && (this.force = t.force), void 0 !== t.smooth && (this.smooth = t.smooth)) } } class pe { constructor() { this.enable = !1, this.mode = [], this.parallax = new ue } load(t) { void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode), this.parallax.load(t.parallax)) } } class ve { constructor() { this.onClick = new he, this.onDiv = new de, this.onHover = new pe, this.resize = !0 } get onclick() { return this.onClick } set onclick(t) { this.onClick = t } get ondiv() { return this.onDiv } set ondiv(t) { this.onDiv = t } get onhover() { return this.onHover } set onhover(t) { this.onHover = t } load(t) { var e, i, o; if (void 0 === t) return; this.onClick.load(null !== (e = t.onClick) && void 0 !== e ? e : t.onclick); const n = null !== (i = t.onDiv) && void 0 !== i ? i : t.ondiv; void 0 !== n && (n instanceof Array ? this.onDiv = n.map(t => { const e = new de; return e.load(t), e }) : (this.onDiv = new de, this.onDiv.load(n))), this.onHover.load(null !== (o = t.onHover) && void 0 !== o ? o : t.onhover), void 0 !== t.resize && (this.resize = t.resize) } } class ge { constructor() { this.distance = 200, this.duration = .4 } load(t) { void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.color && (t.color instanceof Array ? this.color = t.color.map(t => nt.create(void 0, t)) : (this.color instanceof Array && (this.color = new nt), this.color = nt.create(this.color, t.color))), void 0 !== t.size && (this.size = t.size)) } } class ye extends ge { constructor() { super(), this.selectors = [] } get ids() { return this.selectors instanceof Array ? this.selectors.map(t => t.replace("#", "")) : this.selectors.replace("#", "") } set ids(t) { t instanceof Array ? this.selectors = t.map(t => `#${t}`) : this.selectors = `#${t}` } load(t) { super.load(t), void 0 !== t && (void 0 !== t.ids && (this.ids = t.ids), void 0 !== t.selectors && (this.selectors = t.selectors)) } } class fe extends ge { load(t) { super.load(t), void 0 !== t && void 0 !== t.divs && (t.divs instanceof Array ? this.divs = t.divs.map(t => { const e = new ye; return e.load(t), e }) : ((this.divs instanceof Array || !this.divs) && (this.divs = new ye), this.divs.load(t.divs))) } } class me { constructor() { this.opacity = .5 } load(t) { void 0 !== t && void 0 !== t.opacity && (this.opacity = t.opacity) } } class we { constructor() { this.distance = 80, this.links = new me, this.radius = 60 } get line_linked() { return this.links } set line_linked(t) { this.links = t } get lineLinked() { return this.links } set lineLinked(t) { this.links = t } load(t) { var e, i; void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), this.links.load(null !== (i = null !== (e = t.links) && void 0 !== e ? e : t.lineLinked) && void 0 !== i ? i : t.line_linked), void 0 !== t.radius && (this.radius = t.radius)) } } class Se { constructor() { this.blink = !1, this.consent = !1, this.opacity = 1 } load(t) { void 0 !== t && (void 0 !== t.blink && (this.blink = t.blink), void 0 !== t.color && (this.color = nt.create(this.color, t.color)), void 0 !== t.consent && (this.consent = t.consent), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class be { constructor() { this.distance = 100, this.links = new Se } get line_linked() { return this.links } set line_linked(t) { this.links = t } get lineLinked() { return this.links } set lineLinked(t) { this.links = t } load(t) { var e, i; void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), this.links.load(null !== (i = null !== (e = t.links) && void 0 !== e ? e : t.lineLinked) && void 0 !== i ? i : t.line_linked)) } } class Pe { constructor() { this.quantity = 2 } get particles_nb() { return this.quantity } set particles_nb(t) { this.quantity = t } load(t) { var e; if (void 0 === t) return; const i = null !== (e = t.quantity) && void 0 !== e ? e : t.particles_nb; void 0 !== i && (this.quantity = i) } } class _e { constructor() { this.quantity = 4 } get particles_nb() { return this.quantity } set particles_nb(t) { this.quantity = t } load(t) { var e; if (void 0 === t) return; const i = null !== (e = t.quantity) && void 0 !== e ? e : t.particles_nb; void 0 !== i && (this.quantity = i) } } class xe { constructor() { this.distance = 200, this.duration = .4, this.speed = 1 } load(t) { void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.speed && (this.speed = t.speed)) } } class Ae extends xe { constructor() { super(), this.selectors = [] } get ids() { return this.selectors instanceof Array ? this.selectors.map(t => t.replace("#", "")) : this.selectors.replace("#", "") } set ids(t) { t instanceof Array ? this.selectors = t.map(() => `#${t}`) : this.selectors = `#${t}` } load(t) { super.load(t), void 0 !== t && (void 0 !== t.ids && (this.ids = t.ids), void 0 !== t.selectors && (this.selectors = t.selectors)) } } class Ce extends xe { load(t) { super.load(t), void 0 !== (null == t ? void 0 : t.divs) && (t.divs instanceof Array ? this.divs = t.divs.map(t => { const e = new Ae; return e.load(t), e }) : ((this.divs instanceof Array || !this.divs) && (this.divs = new Ae), this.divs.load(t.divs))) } } class Ve { constructor() { this.factor = 3, this.radius = 200 } get active() { return !1 } set active(t) { } load(t) { void 0 !== t && (void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.radius && (this.radius = t.radius)) } } class Ge { constructor() { this.delay = 1, this.quantity = 1 } load(t) { void 0 !== t && (void 0 !== t.delay && (this.delay = t.delay), void 0 !== t.quantity && (this.quantity = t.quantity), void 0 !== t.particles && (this.particles = A.deepExtend({}, t.particles))) } } class Re { constructor() { this.distance = 200, this.duration = .4, this.speed = 1 } load(t) { void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.speed && (this.speed = t.speed)) } } class Te { constructor() { this.start = new nt, this.stop = new nt, this.start.value = "#ffffff", this.stop.value = "#000000" } load(t) { void 0 !== t && (this.start = nt.create(this.start, t.start), this.stop = nt.create(this.stop, t.stop)) } } class Oe { constructor() { this.gradient = new Te, this.radius = 1e3 } load(t) { void 0 !== t && (this.gradient.load(t.gradient), void 0 !== t.radius && (this.radius = t.radius)) } } class Ee { constructor() { this.color = new nt, this.color.value = "#000000", this.length = 2e3 } load(t) { void 0 !== t && (this.color = nt.create(this.color, t.color), void 0 !== t.length && (this.length = t.length)) } } class ke { constructor() { this.area = new Oe, this.shadow = new Ee } load(t) { void 0 !== t && (this.area.load(t.area), this.shadow.load(t.shadow)) } } class Me { constructor() { this.distance = 200 } load(t) { t && void 0 !== t.distance && (this.distance = t.distance) } } class Le { constructor() { this.attract = new Re, this.bounce = new Me, this.bubble = new fe, this.connect = new we, this.grab = new be, this.light = new ke, this.push = new _e, this.remove = new Pe, this.repulse = new Ce, this.slow = new Ve, this.trail = new Ge } load(t) { void 0 !== t && (this.attract.load(t.attract), this.bubble.load(t.bubble), this.connect.load(t.connect), this.grab.load(t.grab), this.light.load(t.light), this.push.load(t.push), this.remove.load(t.remove), this.repulse.load(t.repulse), this.slow.load(t.slow), this.trail.load(t.trail)) } } class Ie { constructor() { this.detectsOn = b.canvas, this.events = new ve, this.modes = new Le } get detect_on() { return this.detectsOn } set detect_on(t) { this.detectsOn = t } load(t) { var e, i, o; if (void 0 === t) return; const n = null !== (e = t.detectsOn) && void 0 !== e ? e : t.detect_on; void 0 !== n && (this.detectsOn = n), this.events.load(t.events), this.modes.load(t.modes), !0 === (null === (o = null === (i = t.modes) || void 0 === i ? void 0 : i.slow) || void 0 === o ? void 0 : o.active) && (this.events.onHover.mode instanceof Array ? this.events.onHover.mode.indexOf(h.slow) < 0 && this.events.onHover.mode.push(h.slow) : this.events.onHover.mode !== h.slow && (this.events.onHover.mode = [this.events.onHover.mode, h.slow])) } } class ze { constructor() { this.color = new nt, this.opacity = 1 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = nt.create(this.color, t.color)), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class He { constructor() { this.composite = "destination-out", this.cover = new ze, this.enable = !1 } load(t) { if (void 0 !== t) { if (void 0 !== t.composite && (this.composite = t.composite), void 0 !== t.cover) { const e = t.cover, i = "string" == typeof t.cover ? { color: t.cover } : t.cover; this.cover.load(void 0 !== e.color ? e : { color: i }) } void 0 !== t.enable && (this.enable = t.enable) } } } class De { constructor() { this.color = new nt, this.color.value = "", this.image = "", this.position = "", this.repeat = "", this.size = "", this.opacity = 1 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = nt.create(this.color, t.color)), void 0 !== t.image && (this.image = t.image), void 0 !== t.position && (this.position = t.position), void 0 !== t.repeat && (this.repeat = t.repeat), void 0 !== t.size && (this.size = t.size), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class Fe { constructor() { this.color = new nt, this.color.value = "#ff0000", this.radius = 0, this.rate = 1 } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = nt.create(this.color, t.color)), this.duration = t.duration, this.infectedStage = t.infectedStage, void 0 !== t.radius && (this.radius = t.radius), void 0 !== t.rate && (this.rate = t.rate)) } } class Ne { constructor() { this.cure = !1, this.delay = 0, this.enable = !1, this.infections = 0, this.stages = [] } load(t) { void 0 !== t && (void 0 !== t.cure && (this.cure = t.cure), void 0 !== t.delay && (this.delay = t.delay), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.infections && (this.infections = t.infections), void 0 !== t.stages && (this.stages = t.stages.map(t => { const e = new Fe; return e.load(t), e }))) } } class Be { constructor() { this.mode = v.any, this.value = !1 } load(t) { void 0 !== t && (void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.value && (this.value = t.value)) } } class je { constructor() { this.name = "", this.default = new Be } load(t) { void 0 !== t && (void 0 !== t.name && (this.name = t.name), this.default.load(t.default), void 0 !== t.options && (this.options = A.deepExtend({}, t.options))) } } class qe { constructor() { this.enable = !1, this.zIndex = -1 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.zIndex && (this.zIndex = t.zIndex)) } } class Ue { constructor() { this.factor = 4, this.value = !0 } load(t) { t && (void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.value && (this.value = t.value)) } } class Qe { constructor() { this.disable = !1, this.reduce = new Ue } load(t) { t && (void 0 !== t.disable && (this.disable = t.disable), this.reduce.load(t.reduce)) } } class We { load(t) { var e, i; t && (void 0 !== t.position && (this.position = { x: null !== (e = t.position.x) && void 0 !== e ? e : 50, y: null !== (i = t.position.y) && void 0 !== i ? i : 50 }), void 0 !== t.options && (this.options = A.deepExtend({}, t.options))) } } class $e { constructor() { this.maxWidth = 1 / 0, this.options = {} } load(t) { t && (void 0 !== t.maxWidth && (this.maxWidth = t.maxWidth), void 0 !== t.options && (this.options = A.deepExtend({}, t.options))) } } class Xe { constructor() { this.autoPlay = !0, this.background = new De, this.backgroundMask = new He, this.fullScreen = new qe, this.detectRetina = !0, this.fpsLimit = 60, this.infection = new Ne, this.interactivity = new Ie, this.manualParticles = [], this.motion = new Qe, this.particles = new Bt, this.pauseOnBlur = !0, this.pauseOnOutsideViewport = !0, this.responsive = [], this.themes = [] } get fps_limit() { return this.fpsLimit } set fps_limit(t) { this.fpsLimit = t } get retina_detect() { return this.detectRetina } set retina_detect(t) { this.detectRetina = t } get backgroundMode() { return this.fullScreen } set backgroundMode(t) { this.fullScreen.load(t) } load(t) { var e, i, o; if (void 0 === t) return; if (void 0 !== t.preset) if (t.preset instanceof Array) for (const e of t.preset) this.importPreset(e); else this.importPreset(t.preset); void 0 !== t.autoPlay && (this.autoPlay = t.autoPlay); const n = null !== (e = t.detectRetina) && void 0 !== e ? e : t.retina_detect; void 0 !== n && (this.detectRetina = n); const s = null !== (i = t.fpsLimit) && void 0 !== i ? i : t.fps_limit; if (void 0 !== s && (this.fpsLimit = s), void 0 !== t.pauseOnBlur && (this.pauseOnBlur = t.pauseOnBlur), void 0 !== t.pauseOnOutsideViewport && (this.pauseOnOutsideViewport = t.pauseOnOutsideViewport), this.background.load(t.background), this.fullScreen.load(null !== (o = t.fullScreen) && void 0 !== o ? o : t.backgroundMode), this.backgroundMask.load(t.backgroundMask), this.infection.load(t.infection), this.interactivity.load(t.interactivity), void 0 !== t.manualParticles && (this.manualParticles = t.manualParticles.map(t => { const e = new We; return e.load(t), e })), this.motion.load(t.motion), this.particles.load(t.particles), B.loadOptions(this, t), void 0 !== t.responsive) for (const e of t.responsive) { const t = new $e; t.load(e), this.responsive.push(t) } if (this.responsive.sort((t, e) => t.maxWidth - e.maxWidth), void 0 !== t.themes) for (const e of t.themes) { const t = new je; t.load(e), this.themes.push(t) } } setTheme(t) { if (t) { const e = this.themes.find(e => e.name === t); e && this.load(e.options) } else { const t = "undefined" != typeof matchMedia && matchMedia("(prefers-color-scheme: dark)").matches; let e = this.themes.find(e => e.default.value && (e.default.mode === v.dark && t || e.default.mode === v.light && !t)); e || (e = this.themes.find(t => t.default.value && t.default.mode === v.any)), e && this.load(e.options) } } importPreset(t) { this.load(B.getPreset(t)) } setResponsive(t, e, i) { var o; this.load(i), this.load(null === (o = this.responsive.find(i => i.maxWidth * e > t)) || void 0 === o ? void 0 : o.options) } } var Ye = function (t, e, i, o) { return new (i || (i = Promise))(function (n, s) { function a(t) { try { c(o.next(t)) } catch (t) { s(t) } } function r(t) { try { c(o.throw(t)) } catch (t) { s(t) } } function c(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) { t(e) })).then(a, r) } c((o = o.apply(t, e || [])).next()) }) }; class Je { constructor(t, e, ...i) { this.id = t, this.sourceOptions = e, this.fpsLimit = 60, this.firstStart = !0, this.started = !1, this.destroyed = !1, this.paused = !0, this.lastFrameTime = 0, this.pageHidden = !1, this.retina = new ce(this), this.canvas = new et(this), this.particles = new re(this), this.drawer = new le(this), this.pathGenerator = { generate: () => { const t = a.create(0, 0); return t.length = Math.random(), t.angle = Math.random() * Math.PI * 2, t }, init: () => { }, update: () => { } }, this.interactivity = { mouse: { clicking: !1, inside: !1 } }, this.bubble = {}, this.repulse = { particles: [] }, this.attract = { particles: [] }, this.plugins = new Map, this.drawers = new Map, this.density = 1, this.options = new Xe, this.actualOptions = new Xe; for (const t of i) this.options.load(B.getPreset(t)); const o = B.getSupportedShapes(); for (const t of o) { const e = B.getShapeDrawer(t); e && this.drawers.set(t, e) } this.options && this.options.load(this.sourceOptions), this.eventListeners = new z(this), "undefined" != typeof IntersectionObserver && IntersectionObserver && (this.intersectionObserver = new IntersectionObserver(t => this.intersectionManager(t))) } play(t) { const e = this.paused || t; if (!this.firstStart || this.actualOptions.autoPlay) { if (this.paused && (this.paused = !1), e) { for (const [, t] of this.plugins) t.play && t.play(); this.lastFrameTime = performance.now() } this.draw() } else this.firstStart = !1 } pause() { if (void 0 !== this.drawAnimationFrame && (A.cancelAnimation(this.drawAnimationFrame), delete this.drawAnimationFrame), !this.paused) { for (const [, t] of this.plugins) t.pause && t.pause(); this.pageHidden || (this.paused = !0) } } draw() { this.drawAnimationFrame = A.animate(t => this.drawer.nextFrame(t)) } getAnimationStatus() { return !this.paused } setNoise(t, e, i) { this.setPath(t, e, i) } setPath(t, e, i) { t && ("function" == typeof t ? (this.pathGenerator.generate = t, e && (this.pathGenerator.init = e), i && (this.pathGenerator.update = i)) : (t.generate && (this.pathGenerator.generate = t.generate), t.init && (this.pathGenerator.init = t.init), t.update && (this.pathGenerator.update = t.update))) } destroy() { this.stop(), this.canvas.destroy(); for (const [, t] of this.drawers) t.destroy && t.destroy(this); for (const t of this.drawers.keys()) this.drawers.delete(t); this.destroyed = !0 } exportImg(t) { this.exportImage(t) } exportImage(t, e, i) { var o; return null === (o = this.canvas.element) || void 0 === o ? void 0 : o.toBlob(t, null != e ? e : "image/png", i) } exportConfiguration() { return JSON.stringify(this.actualOptions, void 0, 2) } refresh() { return Ye(this, void 0, void 0, function* () { this.stop(), yield this.start() }) } stop() { if (this.started) { this.firstStart = !0, this.started = !1, this.eventListeners.removeListeners(), this.pause(), this.particles.clear(), this.canvas.clear(), this.interactivity.element instanceof HTMLElement && this.intersectionObserver && this.intersectionObserver.observe(this.interactivity.element); for (const [, t] of this.plugins) t.stop && t.stop(); for (const t of this.plugins.keys()) this.plugins.delete(t); this.particles.linksColors = new Map, delete this.particles.grabLineColor, delete this.particles.linksColor } } loadTheme(t) { return Ye(this, void 0, void 0, function* () { this.actualOptions.setTheme(t), yield this.refresh() }) } start() { return Ye(this, void 0, void 0, function* () { if (!this.started) { yield this.init(), this.started = !0, this.eventListeners.addListeners(), this.interactivity.element instanceof HTMLElement && this.intersectionObserver && this.intersectionObserver.observe(this.interactivity.element); for (const [, t] of this.plugins) void 0 !== t.startAsync ? yield t.startAsync() : void 0 !== t.start && t.start(); this.play() } }) } init() { return Ye(this, void 0, void 0, function* () { this.actualOptions = new Xe, this.actualOptions.load(this.options), this.retina.init(), this.canvas.init(), this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, this.options), this.actualOptions.setTheme(void 0), this.fpsLimit = this.actualOptions.fpsLimit > 0 ? this.actualOptions.fpsLimit : 60; const t = B.getAvailablePlugins(this); for (const [e, i] of t) this.plugins.set(e, i); for (const [, t] of this.drawers) t.init && (yield t.init(this)); for (const [, t] of this.plugins) t.init ? t.init(this.actualOptions) : void 0 !== t.initAsync && (yield t.initAsync(this.actualOptions)); this.canvas.resize(), this.particles.init(), this.particles.setDensity() }) } intersectionManager(t) { if (this.actualOptions.pauseOnOutsideViewport) for (const e of t) e.target === this.interactivity.element && (e.isIntersecting ? this.play() : this.pause()) } } var Ze = function (t, e, i, o) { return new (i || (i = Promise))(function (n, s) { function a(t) { try { c(o.next(t)) } catch (t) { s(t) } } function r(t) { try { c(o.throw(t)) } catch (t) { s(t) } } function c(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) { t(e) })).then(a, r) } c((o = o.apply(t, e || [])).next()) }) }; const Ke = []; function ti(t) { console.error(`Error tsParticles - fetch status: ${t}`), console.error("Error tsParticles - File config not found") } class ei { static dom() { return Ke } static domItem(t) { const e = ei.dom(), i = e[t]; if (i && !i.destroyed) return i; e.splice(t, 1) } static load(t, e, i) { return Ze(this, void 0, void 0, function* () { const o = document.getElementById(t); if (o) return ei.set(t, o, e, i) }) } static set(t, e, i, o) { return Ze(this, void 0, void 0, function* () { const n = i instanceof Array ? A.itemFromArray(i, o) : i, s = ei.dom(), a = s.findIndex(e => e.id === t); if (a >= 0) { const t = ei.domItem(a); t && !t.destroyed && (t.destroy(), s.splice(a, 1)) } let r, c; if ("canvas" === e.tagName.toLowerCase()) r = e, c = !1; else { const t = e.getElementsByTagName("canvas"); t.length ? ((r = t[0]).className || (r.className = C.canvasClass), c = !1) : (c = !0, (r = document.createElement("canvas")).className = C.canvasClass, r.style.width = "100%", r.style.height = "100%", e.appendChild(r)) } const l = new Je(t, n); return a >= 0 ? s.splice(a, 0, l) : s.push(l), l.canvas.loadCanvas(r, c), yield l.start(), l }) } static loadJSON(t, e, i) { return Ze(this, void 0, void 0, function* () { const o = e instanceof Array ? A.itemFromArray(e, i) : e, n = yield fetch(o); if (n.ok) return ei.load(t, yield n.json()); ti(n.status) }) } static setJSON(t, e, i) { return Ze(this, void 0, void 0, function* () { const o = yield fetch(i); if (o.ok) { const i = yield o.json(); return ei.set(t, e, i) } ti(o.status) }) } static setOnClickHandler(t) { const e = ei.dom(); if (0 === e.length) throw new Error("Can only set click handlers after calling tsParticles.load() or tsParticles.loadJSON()"); for (const i of e) { const e = i.interactivity.element; if (!e) continue; const o = (e, o) => { if (i.destroyed) return; const n = i.retina.pixelRatio, s = { x: o.x * n, y: o.y * n }, a = i.particles.quadTree.queryCircle(s, i.retina.sizeValue); t(e, a) }, n = t => { if (i.destroyed) return; const e = t, n = { x: e.offsetX || e.clientX, y: e.offsetY || e.clientY }; o(t, n) }, s = () => { i.destroyed || (l = !0, h = !1) }, a = () => { i.destroyed || (h = !0) }, r = t => { var e, n, s; if (!i.destroyed) { if (l && !h) { const a = t, r = a.touches[a.touches.length - 1], c = null === (e = i.canvas.element) || void 0 === e ? void 0 : e.getBoundingClientRect(), l = { x: r.clientX - (null !== (n = null == c ? void 0 : c.left) && void 0 !== n ? n : 0), y: r.clientY - (null !== (s = null == c ? void 0 : c.top) && void 0 !== s ? s : 0) }; o(t, l) } l = !1, h = !1 } }, c = () => { i.destroyed || (l = !1, h = !1) }; let l = !1, h = !1; e.addEventListener("click", n), e.addEventListener("touchstart", s), e.addEventListener("touchmove", a), e.addEventListener("touchend", r), e.addEventListener("touchcancel", c) } } } var ii, oi, ni = function (t, e, i, o) { return new (i || (i = Promise))(function (n, s) { function a(t) { try { c(o.next(t)) } catch (t) { s(t) } } function r(t) { try { c(o.throw(t)) } catch (t) { s(t) } } function c(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) { t(e) })).then(a, r) } c((o = o.apply(t, e || [])).next()) }) }, si = function (t, e, i) { if (!e.has(t)) throw new TypeError("attempted to set private field on non-instance"); return e.set(t, i), i }, ai = function (t, e) { if (!e.has(t)) throw new TypeError("attempted to get private field on non-instance"); return e.get(t) }; class ri { constructor() { ii.set(this, void 0), si(this, ii, !1); const t = new i, e = new Q, o = new $; B.addShapeDrawer(m.line, new X), B.addShapeDrawer(m.circle, new Y), B.addShapeDrawer(m.edge, t), B.addShapeDrawer(m.square, t), B.addShapeDrawer(m.triangle, new Z), B.addShapeDrawer(m.star, new K), B.addShapeDrawer(m.polygon, new tt), B.addShapeDrawer(m.char, e), B.addShapeDrawer(m.character, e), B.addShapeDrawer(m.image, o), B.addShapeDrawer(m.images, o) } init() { ai(this, ii) || si(this, ii, !0) } loadFromArray(t, e, i) { return ni(this, void 0, void 0, function* () { return ei.load(t, e, i) }) } load(t, e) { return ni(this, void 0, void 0, function* () { return ei.load(t, e) }) } set(t, e, i) { return ni(this, void 0, void 0, function* () { return ei.set(t, e, i) }) } loadJSON(t, e, i) { return ei.loadJSON(t, e, i) } setOnClickHandler(t) { ei.setOnClickHandler(t) } dom() { return ei.dom() } domItem(t) { return ei.domItem(t) } addShape(t, e, i, o, n) { let s; s = "function" == typeof e ? { afterEffect: o, destroy: n, draw: e, init: i } : e, B.addShapeDrawer(t, s) } addPreset(t, e) { B.addPreset(t, e) } addPlugin(t) { B.addPlugin(t) } addPathGenerator(t, e) { B.addPathGenerator(t, e) } } ii = new WeakMap; class ci { constructor(t, e, i, o) { var n, s, c; this.absorbers = t, this.container = e, this.initialPosition = o ? a.create(o.x, o.y) : void 0, this.options = i, this.dragging = !1, this.name = this.options.name, this.opacity = this.options.opacity, this.size = r.getValue(i.size) * e.retina.pixelRatio, this.mass = this.size * i.size.density * e.retina.reduceFactor; const l = i.size.limit; this.limit = void 0 !== l ? l * e.retina.pixelRatio * e.retina.reduceFactor : l; const h = "string" == typeof i.color ? { value: i.color } : i.color; this.color = null !== (n = R.colorToRgb(h)) && void 0 !== n ? n : { b: 0, g: 0, r: 0 }, this.position = null !== (c = null === (s = this.initialPosition) || void 0 === s ? void 0 : s.copy()) && void 0 !== c ? c : this.calcPosition() } attract(t) { const e = this.options; if (e.draggable) { const t = this.container.interactivity.mouse; if (t.clicking && t.downPosition) { r.getDistance(this.position, t.downPosition) <= this.size && (this.dragging = !0) } else this.dragging = !1; this.dragging && t.position && (this.position.x = t.position.x, this.position.y = t.position.y) } const i = t.getPosition(), { dx: o, dy: n, distance: s } = r.getDistances(this.position, i), c = a.create(o, n); if (c.length = this.mass / Math.pow(s, 2) * this.container.retina.reduceFactor, s < this.size + t.getRadius()) { const i = .033 * t.getRadius() * this.container.retina.pixelRatio; this.size > t.getRadius() && s < this.size - t.getRadius() ? e.destroy ? t.destroy() : (t.needsNewPosition = !0, this.updateParticlePosition(t, c)) : (e.destroy && (t.size.value -= i), this.updateParticlePosition(t, c)), (void 0 === this.limit || this.size < this.limit) && (this.size += i), this.mass += i * this.options.size.density * this.container.retina.reduceFactor } else this.updateParticlePosition(t, c) } resize() { const t = this.initialPosition; this.position = t && A.isPointInside(t, this.container.canvas.size) ? t : this.calcPosition() } draw(t) { t.translate(this.position.x, this.position.y), t.beginPath(), t.arc(0, 0, this.size, 0, 2 * Math.PI, !1), t.closePath(), t.fillStyle = R.getStyleFromRgb(this.color, this.opacity), t.fill() } calcPosition() { var t, e; const i = this.container, o = this.options.position; return a.create((null !== (t = null == o ? void 0 : o.x) && void 0 !== t ? t : 100 * Math.random()) / 100 * i.canvas.size.width, (null !== (e = null == o ? void 0 : o.y) && void 0 !== e ? e : 100 * Math.random()) / 100 * i.canvas.size.height) } updateParticlePosition(t, e) { var i; if (t.destroyed) return; const o = this.container.canvas.size; if (t.needsNewPosition) { const e = t.getRadius(); t.position.x = Math.random() * (o.width - 2 * e) + e, t.position.y = Math.random() * (o.height - 2 * e) + e, t.needsNewPosition = !1 } this.options.orbits ? (void 0 === t.orbit && (t.orbit = a.create(0, 0), t.orbit.length = r.getDistance(t.getPosition(), this.position), t.orbit.angle = Math.random() * Math.PI * 2), t.orbit.length <= this.size && !this.options.destroy && (t.orbit.length = Math.random() * Math.max(o.width, o.height)), t.velocity.x = 0, t.velocity.y = 0, t.position.setTo(t.orbit.add(this.position)), t.orbit.length -= e.length, t.orbit.angle += (null !== (i = t.moveSpeed) && void 0 !== i ? i : r.getRangeValue(t.options.move.speed) * this.container.retina.pixelRatio) / 100 * this.container.retina.reduceFactor) : t.velocity.addTo(e) } } class li extends dt { constructor() { super(), this.density = 5, this.random.minimumValue = 1, this.value = 50 } load(t) { t && (super.load(t), void 0 !== t.density && (this.density = t.density), void 0 !== t.limit && (this.limit = t.limit), void 0 !== t.limit && (this.limit = t.limit)) } } class hi { constructor() { this.color = new nt, this.color.value = "#000000", this.draggable = !1, this.opacity = 1, this.destroy = !0, this.orbits = !1, this.size = new li } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = nt.create(this.color, t.color)), void 0 !== t.draggable && (this.draggable = t.draggable), this.name = t.name, void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.position && (this.position = { x: t.position.x, y: t.position.y }), void 0 !== t.size && this.size.load(t.size), void 0 !== t.destroy && (this.destroy = t.destroy), void 0 !== t.orbits && (this.orbits = t.orbits)) } } !function (t) { t.absorber = "absorber" }(oi || (oi = {})); class di { constructor(t) { this.container = t, this.array = [], this.absorbers = [], this.interactivityAbsorbers = [], t.addAbsorber = ((t, e) => this.addAbsorber(t, e)) } init(t) { var e, i; if (!t) return; t.absorbers && (t.absorbers instanceof Array ? this.absorbers = t.absorbers.map(t => { const e = new hi; return e.load(t), e }) : (this.absorbers instanceof Array && (this.absorbers = new hi), this.absorbers.load(t.absorbers))); const o = null === (i = null === (e = t.interactivity) || void 0 === e ? void 0 : e.modes) || void 0 === i ? void 0 : i.absorbers; if (o && (o instanceof Array ? this.interactivityAbsorbers = o.map(t => { const e = new hi; return e.load(t), e }) : (this.interactivityAbsorbers instanceof Array && (this.interactivityAbsorbers = new hi), this.interactivityAbsorbers.load(o))), this.absorbers instanceof Array) for (const t of this.absorbers) this.addAbsorber(t); else this.addAbsorber(this.absorbers) } particleUpdate(t) { for (const e of this.array) if (e.attract(t), t.destroyed) break } draw(t) { for (const e of this.array) t.save(), e.draw(t), t.restore() } stop() { this.array = [] } resize() { for (const t of this.array) t.resize() } handleClickMode(t) { const e = this.container, i = this.absorbers, o = this.interactivityAbsorbers; if (t === oi.absorber) { let t; o instanceof Array ? o.length > 0 && (t = A.itemFromArray(o)) : t = o; const n = null != t ? t : i instanceof Array ? A.itemFromArray(i) : i, s = e.interactivity.mouse.clickPosition; this.addAbsorber(n, s) } } addAbsorber(t, e) { const i = new ci(this, this.container, t, e); return this.array.push(i), i } removeAbsorber(t) { const e = this.array.indexOf(t); e >= 0 && this.array.splice(e, 1) } } const ui = new class { constructor() { this.id = "absorbers" } getPlugin(t) { return new di(t) } needsPlugin(t) { var e, i, o; if (void 0 === t) return !1; const n = t.absorbers; let s = !1; return n instanceof Array ? n.length && (s = !0) : void 0 !== n ? s = !0 : (null === (o = null === (i = null === (e = t.interactivity) || void 0 === e ? void 0 : e.events) || void 0 === i ? void 0 : i.onClick) || void 0 === o ? void 0 : o.mode) && A.isInArray(oi.absorber, t.interactivity.events.onClick.mode) && (s = !0), s } loadOptions(t, e) { var i, o; if (!this.needsPlugin(t) && !this.needsPlugin(e)) return; const n = t; if (null == e ? void 0 : e.absorbers) if ((null == e ? void 0 : e.absorbers) instanceof Array) n.absorbers = null == e ? void 0 : e.absorbers.map(t => { const e = new hi; return e.load(t), e }); else { let t = n.absorbers; void 0 === (null == t ? void 0 : t.load) && (n.absorbers = t = new hi), t.load(null == e ? void 0 : e.absorbers) } const s = null === (o = null === (i = null == e ? void 0 : e.interactivity) || void 0 === i ? void 0 : i.modes) || void 0 === o ? void 0 : o.absorbers; if (s) if (s instanceof Array) n.interactivity.modes.absorbers = s.map(t => { const e = new hi; return e.load(t), e }); else { let t = n.interactivity.modes.absorbers; void 0 === (null == t ? void 0 : t.load) && (n.interactivity.modes.absorbers = t = new hi), t.load(s) } } }; class pi { constructor() { this.mode = p.percent, this.height = 0, this.width = 0 } load(t) { void 0 !== t && (void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.height && (this.height = t.height), void 0 !== t.width && (this.width = t.width)) } } function vi(t, e) { return t + e * (Math.random() - .5) } function gi(t, e) { return { x: vi(t.x, e.x), y: vi(t.y, e.y) } } class yi { constructor(t, e, i, o) { var n, s, a, r; this.emitters = t, this.container = e, this.firstSpawn = !0, this.currentDuration = 0, this.currentEmitDelay = 0, this.currentSpawnDelay = 0, this.initialPosition = o, this.emitterOptions = A.deepExtend({}, i), this.spawnDelay = 1e3 * (null !== (n = this.emitterOptions.life.delay) && void 0 !== n ? n : 0) / this.container.retina.reduceFactor, this.position = null !== (s = this.initialPosition) && void 0 !== s ? s : this.calcPosition(), this.name = i.name; let c = A.deepExtend({}, this.emitterOptions.particles); void 0 === c && (c = {}), void 0 === c.move && (c.move = {}), void 0 === c.move.direction && (c.move.direction = this.emitterOptions.direction), void 0 !== this.emitterOptions.spawnColor && (this.spawnColor = R.colorToHsl(this.emitterOptions.spawnColor)), this.paused = !this.emitterOptions.autoPlay, this.particlesOptions = c, this.size = null !== (a = this.emitterOptions.size) && void 0 !== a ? a : (() => { const t = new pi; return t.load({ height: 0, mode: p.percent, width: 0 }), t })(), this.lifeCount = null !== (r = this.emitterOptions.life.count) && void 0 !== r ? r : -1, this.immortal = this.lifeCount <= 0, this.play() } externalPlay() { this.paused = !1, this.play() } externalPause() { this.paused = !0, this.pause() } play() { this.paused || this.container.retina.reduceFactor && (this.lifeCount > 0 || this.immortal || !this.emitterOptions.life.count) && (void 0 === this.emitDelay && (this.emitDelay = 1e3 * this.emitterOptions.rate.delay / this.container.retina.reduceFactor), (this.lifeCount > 0 || this.immortal) && this.prepareToDie()) } pause() { this.paused || delete this.emitDelay } resize() { const t = this.initialPosition; this.position = t && A.isPointInside(t, this.container.canvas.size) ? t : this.calcPosition() } update(t) { var e, i, o; this.paused || (this.firstSpawn && (this.firstSpawn = !1, this.currentSpawnDelay = null !== (e = this.spawnDelay) && void 0 !== e ? e : 0, this.currentEmitDelay = null !== (i = this.emitDelay) && void 0 !== i ? i : 0, t.value = 0), void 0 !== this.duration && (this.currentDuration += t.value, this.currentDuration >= this.duration && (this.pause(), void 0 !== this.spawnDelay && delete this.spawnDelay, this.immortal || this.lifeCount--, this.lifeCount > 0 || this.immortal ? (this.position = this.calcPosition(), this.spawnDelay = 1e3 * (null !== (o = this.emitterOptions.life.delay) && void 0 !== o ? o : 0) / this.container.retina.reduceFactor) : this.destroy(), this.currentDuration -= this.duration, delete this.duration)), void 0 !== this.spawnDelay && (this.currentSpawnDelay += t.value, this.currentSpawnDelay >= this.spawnDelay && (this.play(), this.currentSpawnDelay -= this.currentSpawnDelay, delete this.spawnDelay)), void 0 !== this.emitDelay && (this.currentEmitDelay += t.value, this.currentEmitDelay >= this.emitDelay && (this.emit(), this.currentEmitDelay -= this.emitDelay))) } prepareToDie() { var t; if (this.paused) return; const e = null === (t = this.emitterOptions.life) || void 0 === t ? void 0 : t.duration; this.container.retina.reduceFactor && (this.lifeCount > 0 || this.immortal) && void 0 !== e && e > 0 && (this.duration = 1e3 * e) } destroy() { this.emitters.removeEmitter(this) } calcPosition() { var t, e; const i = this.container, o = this.emitterOptions.position; return { x: (null !== (t = null == o ? void 0 : o.x) && void 0 !== t ? t : 100 * Math.random()) / 100 * i.canvas.size.width, y: (null !== (e = null == o ? void 0 : o.y) && void 0 !== e ? e : 100 * Math.random()) / 100 * i.canvas.size.height } } emit() { var t; if (this.paused) return; const e = this.container, i = this.position, o = { x: this.size.mode === p.percent ? e.canvas.size.width * this.size.width / 100 : this.size.width, y: this.size.mode === p.percent ? e.canvas.size.height * this.size.height / 100 : this.size.height }; for (let n = 0; n < this.emitterOptions.rate.quantity; n++) { const n = A.deepExtend({}, this.particlesOptions); if (void 0 !== this.spawnColor) { const e = null === (t = this.emitterOptions.spawnColor) || void 0 === t ? void 0 : t.animation; if (e) { const t = e; if (t.enable) this.spawnColor.h = this.setColorAnimation(t, this.spawnColor.h, 360); else { const t = e; this.spawnColor.h = this.setColorAnimation(t.h, this.spawnColor.h, 360), this.spawnColor.s = this.setColorAnimation(t.s, this.spawnColor.s, 100), this.spawnColor.l = this.setColorAnimation(t.l, this.spawnColor.l, 100) } } n.color ? n.color.value = this.spawnColor : n.color = { value: this.spawnColor } } e.particles.addParticle(gi(i, o), n) } } setColorAnimation(t, e, i) { var o; const n = this.container; if (!t.enable) return e; const s = r.randomInRange(t.offset), a = 1e3 * this.emitterOptions.rate.delay / n.retina.reduceFactor; return (e + (null !== (o = t.speed) && void 0 !== o ? o : 0) * n.fpsLimit / a + 3.6 * s) % i } } class fi { constructor() { this.quantity = 1, this.delay = .1 } load(t) { void 0 !== t && (void 0 !== t.quantity && (this.quantity = t.quantity), void 0 !== t.delay && (this.delay = t.delay)) } } class mi { load(t) { void 0 !== t && (void 0 !== t.count && (this.count = t.count), void 0 !== t.delay && (this.delay = t.delay), void 0 !== t.duration && (this.duration = t.duration)) } } class wi { constructor() { this.autoPlay = !0, this.direction = n.none, this.life = new mi, this.rate = new fi } load(t) { void 0 !== t && (void 0 !== t.autoPlay && (this.autoPlay = t.autoPlay), void 0 !== t.size && (void 0 === this.size && (this.size = new pi), this.size.load(t.size)), void 0 !== t.direction && (this.direction = t.direction), this.life.load(t.life), this.name = t.name, void 0 !== t.particles && (this.particles = A.deepExtend({}, t.particles)), this.rate.load(t.rate), void 0 !== t.position && (this.position = { x: t.position.x, y: t.position.y }), void 0 !== t.spawnColor && (void 0 === this.spawnColor && (this.spawnColor = new Ot), this.spawnColor.load(t.spawnColor))) } } var Si; !function (t) { t.emitter = "emitter" }(Si || (Si = {})); class bi { constructor(t) { this.container = t, this.array = [], this.emitters = [], this.interactivityEmitters = []; const e = t; e.addEmitter = ((t, e) => this.addEmitter(t, e)), e.playEmitter = (t => { const e = void 0 === t || "number" == typeof t ? this.array[t || 0] : this.array.find(e => e.name === t); e && e.externalPlay() }), e.pauseEmitter = (t => { const e = void 0 === t || "number" == typeof t ? this.array[t || 0] : this.array.find(e => e.name === t); e && e.externalPause() }) } init(t) { var e, i; if (!t) return; t.emitters && (t.emitters instanceof Array ? this.emitters = t.emitters.map(t => { const e = new wi; return e.load(t), e }) : (this.emitters instanceof Array && (this.emitters = new wi), this.emitters.load(t.emitters))); const o = null === (i = null === (e = t.interactivity) || void 0 === e ? void 0 : e.modes) || void 0 === i ? void 0 : i.emitters; if (o && (o instanceof Array ? this.interactivityEmitters = o.map(t => { const e = new wi; return e.load(t), e }) : (this.interactivityEmitters instanceof Array && (this.interactivityEmitters = new wi), this.interactivityEmitters.load(o))), this.emitters instanceof Array) for (const t of this.emitters) this.addEmitter(t); else this.addEmitter(this.emitters) } play() { for (const t of this.array) t.play() } pause() { for (const t of this.array) t.pause() } stop() { this.array = [] } update(t) { for (const e of this.array) e.update(t) } handleClickMode(t) { const e = this.container, i = this.emitters, o = this.interactivityEmitters; if (t === Si.emitter) { let t; o instanceof Array ? o.length > 0 && (t = A.itemFromArray(o)) : t = o; const n = null != t ? t : i instanceof Array ? A.itemFromArray(i) : i, s = e.interactivity.mouse.clickPosition; this.addEmitter(A.deepExtend({}, n), s) } } resize() { for (const t of this.array) t.resize() } addEmitter(t, e) { const i = new yi(this, this.container, t, e); return this.array.push(i), i } removeEmitter(t) { const e = this.array.indexOf(t); e >= 0 && this.array.splice(e, 1) } } const Pi = new class { constructor() { this.id = "emitters" } getPlugin(t) { return new bi(t) } needsPlugin(t) { var e, i, o; if (void 0 === t) return !1; const n = t.emitters; let s = !1; return n instanceof Array ? n.length && (s = !0) : void 0 !== n ? s = !0 : (null === (o = null === (i = null === (e = t.interactivity) || void 0 === e ? void 0 : e.events) || void 0 === i ? void 0 : i.onClick) || void 0 === o ? void 0 : o.mode) && A.isInArray(Si.emitter, t.interactivity.events.onClick.mode) && (s = !0), s } loadOptions(t, e) { var i, o; if (!this.needsPlugin(t) && !this.needsPlugin(e)) return; const n = t; if (null == e ? void 0 : e.emitters) if ((null == e ? void 0 : e.emitters) instanceof Array) n.emitters = null == e ? void 0 : e.emitters.map(t => { const e = new wi; return e.load(t), e }); else { let t = n.emitters; void 0 === (null == t ? void 0 : t.load) && (n.emitters = t = new wi), t.load(null == e ? void 0 : e.emitters) } const s = null === (o = null === (i = null == e ? void 0 : e.interactivity) || void 0 === i ? void 0 : i.modes) || void 0 === o ? void 0 : o.emitters; if (s) if (s instanceof Array) n.interactivity.modes.emitters = s.map(t => { const e = new wi; return e.load(t), e }); else { let t = n.interactivity.modes.emitters; void 0 === (null == t ? void 0 : t.load) && (n.interactivity.modes.emitters = t = new wi), t.load(s) } } }; var _i, xi, Ai; !function (t) { t.equidistant = "equidistant", t.onePerPoint = "one-per-point", t.perPoint = "per-point", t.randomLength = "random-length", t.randomPoint = "random-point" }(_i || (_i = {})), function (t) { t.path = "path", t.radius = "radius" }(xi || (xi = {})), function (t) { t.inline = "inline", t.inside = "inside", t.outside = "outside", t.none = "none" }(Ai || (Ai = {})); class Ci { constructor() { this.color = new nt, this.width = .5, this.opacity = 1 } load(t) { var e; void 0 !== t && (this.color = nt.create(this.color, t.color), "string" == typeof this.color.value && (this.opacity = null !== (e = R.stringToAlpha(this.color.value)) && void 0 !== e ? e : this.opacity), void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.width && (this.width = t.width)) } } class Vi { constructor() { this.enable = !1, this.stroke = new Ci } get lineWidth() { return this.stroke.width } set lineWidth(t) { this.stroke.width = t } get lineColor() { return this.stroke.color } set lineColor(t) { this.stroke.color = nt.create(this.stroke.color, t) } load(t) { var e; if (void 0 !== t) { void 0 !== t.enable && (this.enable = t.enable); const i = null !== (e = t.stroke) && void 0 !== e ? e : { color: t.lineColor, width: t.lineWidth }; this.stroke.load(i) } } } class Gi { constructor() { this.radius = 10, this.type = xi.path } load(t) { void 0 !== t && (void 0 !== t.radius && (this.radius = t.radius), void 0 !== t.type && (this.type = t.type)) } } class Ri { constructor() { this.arrangement = _i.onePerPoint } load(t) { void 0 !== t && void 0 !== t.arrangement && (this.arrangement = t.arrangement) } } class Ti { constructor() { this.path = [], this.size = { height: 0, width: 0 } } load(t) { void 0 !== t && (void 0 !== t.path && (this.path = t.path), void 0 !== t.size && (void 0 !== t.size.width && (this.size.width = t.size.width), void 0 !== t.size.height && (this.size.height = t.size.height))) } } class Oi { constructor() { this.draw = new Vi, this.enable = !1, this.inline = new Ri, this.move = new Gi, this.scale = 1, this.type = Ai.none } get inlineArrangement() { return this.inline.arrangement } set inlineArrangement(t) { this.inline.arrangement = t } load(t) { var e; if (void 0 !== t) { this.draw.load(t.draw); const i = null !== (e = t.inline) && void 0 !== e ? e : { arrangement: t.inlineArrangement }; void 0 !== i && this.inline.load(i), this.move.load(t.move), void 0 !== t.scale && (this.scale = t.scale), void 0 !== t.type && (this.type = t.type), void 0 !== t.enable ? this.enable = t.enable : this.enable = this.type !== Ai.none, void 0 !== t.url && (this.url = t.url), void 0 !== t.data && ("string" == typeof t.data ? this.data = t.data : (this.data = new Ti, this.data.load(t.data))), void 0 !== t.position && (this.position = A.deepExtend({}, t.position)) } } } var Ei = function (t, e, i, o) { return new (i || (i = Promise))(function (n, s) { function a(t) { try { c(o.next(t)) } catch (t) { s(t) } } function r(t) { try { c(o.throw(t)) } catch (t) { s(t) } } function c(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) { t(e) })).then(a, r) } c((o = o.apply(t, e || [])).next()) }) }; function ki(t) { t.velocity.x = t.velocity.y / 2 - t.velocity.x, t.velocity.y = t.velocity.x / 2 - t.velocity.y } function Mi(t, e, i) { const o = R.colorToRgb(i.color); if (o) { t.beginPath(), t.moveTo(e[0].x, e[0].y); for (const i of e) t.lineTo(i.x, i.y); t.closePath(), t.strokeStyle = R.getStyleFromRgb(o), t.lineWidth = i.width, t.stroke() } } function Li(t, e, i, o) { t.translate(o.x, o.y); const n = R.colorToRgb(i.color); n && (t.strokeStyle = R.getStyleFromRgb(n, i.opacity), t.lineWidth = i.width, t.stroke(e)) } class Ii { constructor(t) { this.container = t, this.dimension = { height: 0, width: 0 }, this.path2DSupported = !!window.Path2D, this.options = new Oi, this.polygonMaskMoveRadius = this.options.move.radius * t.retina.pixelRatio } initAsync(t) { return Ei(this, void 0, void 0, function* () { this.options.load(null == t ? void 0 : t.polygon); const e = this.options; this.polygonMaskMoveRadius = e.move.radius * this.container.retina.pixelRatio, e.enable && (yield this.initRawData()) }) } resize() { const t = this.container, e = this.options; e.enable && e.type !== Ai.none && (this.redrawTimeout && clearTimeout(this.redrawTimeout), this.redrawTimeout = window.setTimeout(() => Ei(this, void 0, void 0, function* () { yield this.initRawData(!0), t.particles.redraw() }), 250)) } stop() { delete this.raw, delete this.paths } particlesInitialization() { const t = this.options; return !(!t.enable || t.type !== Ai.inline || t.inline.arrangement !== _i.onePerPoint && t.inline.arrangement !== _i.perPoint) && (this.drawPoints(), !0) } particlePosition(t) { var e, i; if (this.options.enable && (null !== (i = null === (e = this.raw) || void 0 === e ? void 0 : e.length) && void 0 !== i ? i : 0) > 0) return A.deepExtend({}, t || this.randomPoint()) } particleBounce(t) { const e = this.options; if (e.enable && e.type !== Ai.none && e.type !== Ai.inline) { if (!this.checkInsidePolygon(t.getPosition())) return ki(t), !0 } else if (e.enable && e.type === Ai.inline && t.initialPosition) { if (r.getDistance(t.initialPosition, t.getPosition()) > this.polygonMaskMoveRadius) return ki(t), !0 } return !1 } clickPositionValid(t) { const e = this.options; return e.enable && e.type !== Ai.none && e.type !== Ai.inline && this.checkInsidePolygon(t) } draw(t) { var e; if (!(null === (e = this.paths) || void 0 === e ? void 0 : e.length)) return; const i = this.options, o = i.draw; if (!i.enable || !o.enable) return; const n = this.raw; for (const e of this.paths) { const i = e.path2d, s = this.path2DSupported; t && (s && i && this.offset ? Li(t, i, o.stroke, this.offset) : n && Mi(t, n, o.stroke)) } } checkInsidePolygon(t) { var e, i; const o = this.container, n = this.options; if (!n.enable || n.type === Ai.none || n.type === Ai.inline) return !0; if (!this.raw) throw new Error(C.noPolygonFound); const s = o.canvas.size, a = null !== (e = null == t ? void 0 : t.x) && void 0 !== e ? e : Math.random() * s.width, r = null !== (i = null == t ? void 0 : t.y) && void 0 !== i ? i : Math.random() * s.height; let c = !1; for (let t = 0, e = this.raw.length - 1; t < this.raw.length; e = t++) { const i = this.raw[t], o = this.raw[e]; i.y > r != o.y > r && a < (o.x - i.x) * (r - i.y) / (o.y - i.y) + i.x && (c = !c) } return n.type === Ai.inside ? c : n.type === Ai.outside && !c } parseSvgPath(t, e) { var i, o, n; const s = null != e && e; if (void 0 !== this.paths && !s) return this.raw; const a = this.container, r = this.options, c = (new DOMParser).parseFromString(t, "image/svg+xml"), l = c.getElementsByTagName("svg")[0]; let h = l.getElementsByTagName("path"); h.length || (h = c.getElementsByTagName("path")), this.paths = []; for (let t = 0; t < h.length; t++) { const e = h.item(t); e && this.paths.push({ element: e, length: e.getTotalLength() }) } const d = a.retina.pixelRatio, u = r.scale / d; this.dimension.width = parseFloat(null !== (i = l.getAttribute("width")) && void 0 !== i ? i : "0") * u, this.dimension.height = parseFloat(null !== (o = l.getAttribute("height")) && void 0 !== o ? o : "0") * u; const p = null !== (n = r.position) && void 0 !== n ? n : { x: 50, y: 50 }; return this.offset = { x: a.canvas.size.width * p.x / (100 * d) - this.dimension.width / 2, y: a.canvas.size.height * p.y / (100 * d) - this.dimension.height / 2 }, function (t, e, i) { const o = []; for (const n of t) { const t = n.element.pathSegList, s = t.numberOfItems, a = { x: 0, y: 0 }; for (let n = 0; n < s; n++) { const s = t.getItem(n), r = window.SVGPathSeg; switch (s.pathSegType) { case r.PATHSEG_MOVETO_ABS: case r.PATHSEG_LINETO_ABS: case r.PATHSEG_CURVETO_CUBIC_ABS: case r.PATHSEG_CURVETO_QUADRATIC_ABS: case r.PATHSEG_ARC_ABS: case r.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: case r.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: { const t = s; a.x = t.x, a.y = t.y; break } case r.PATHSEG_LINETO_HORIZONTAL_ABS: a.x = s.x; break; case r.PATHSEG_LINETO_VERTICAL_ABS: a.y = s.y; break; case r.PATHSEG_LINETO_REL: case r.PATHSEG_MOVETO_REL: case r.PATHSEG_CURVETO_CUBIC_REL: case r.PATHSEG_CURVETO_QUADRATIC_REL: case r.PATHSEG_ARC_REL: case r.PATHSEG_CURVETO_CUBIC_SMOOTH_REL: case r.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: { const t = s; a.x += t.x, a.y += t.y; break } case r.PATHSEG_LINETO_HORIZONTAL_REL: a.x += s.x; break; case r.PATHSEG_LINETO_VERTICAL_REL: a.y += s.y; break; case r.PATHSEG_UNKNOWN: case r.PATHSEG_CLOSEPATH: continue }o.push({ x: a.x * e + i.x, y: a.y * e + i.y }) } } return o }(this.paths, u, this.offset) } downloadSvgPath(t, e) { return Ei(this, void 0, void 0, function* () { const i = this.options, o = t || i.url, n = null != e && e; if (!o || void 0 !== this.paths && !n) return this.raw; const s = yield fetch(o); if (!s.ok) throw new Error("tsParticles Error - Error occurred during polygon mask download"); return this.parseSvgPath(yield s.text(), e) }) } drawPoints() { if (this.raw) for (const t of this.raw) this.container.particles.addParticle({ x: t.x, y: t.y }) } randomPoint() { const t = this.container, e = this.options; let i; if (e.type === Ai.inline) switch (e.inline.arrangement) { case _i.randomPoint: i = this.getRandomPoint(); break; case _i.randomLength: i = this.getRandomPointByLength(); break; case _i.equidistant: i = this.getEquidistantPointByIndex(t.particles.count); break; case _i.onePerPoint: case _i.perPoint: default: i = this.getPointByIndex(t.particles.count) } else i = { x: Math.random() * t.canvas.size.width, y: Math.random() * t.canvas.size.height }; return this.checkInsidePolygon(i) ? i : this.randomPoint() } getRandomPoint() { if (!this.raw || !this.raw.length) throw new Error(C.noPolygonDataLoaded); const t = A.itemFromArray(this.raw); return { x: t.x, y: t.y } } getRandomPointByLength() { var t, e, i; const o = this.options; if (!this.raw || !this.raw.length || !(null === (t = this.paths) || void 0 === t ? void 0 : t.length)) throw new Error(C.noPolygonDataLoaded); const n = A.itemFromArray(this.paths), s = Math.floor(Math.random() * n.length) + 1, a = n.element.getPointAtLength(s); return { x: a.x * o.scale + ((null === (e = this.offset) || void 0 === e ? void 0 : e.x) || 0), y: a.y * o.scale + ((null === (i = this.offset) || void 0 === i ? void 0 : i.y) || 0) } } getEquidistantPointByIndex(t) { var e, i, o, n, s, a, r; const c = this.container.actualOptions, l = this.options; if (!this.raw || !this.raw.length || !(null === (e = this.paths) || void 0 === e ? void 0 : e.length)) throw new Error(C.noPolygonDataLoaded); let h, d = 0; const u = this.paths.reduce((t, e) => t + e.length, 0) / c.particles.number.value; for (const e of this.paths) { const i = u * t - d; if (i <= e.length) { h = e.element.getPointAtLength(i); break } d += e.length } return { x: (null !== (i = null == h ? void 0 : h.x) && void 0 !== i ? i : 0) * l.scale + (null !== (n = null === (o = this.offset) || void 0 === o ? void 0 : o.x) && void 0 !== n ? n : 0), y: (null !== (s = null == h ? void 0 : h.y) && void 0 !== s ? s : 0) * l.scale + (null !== (r = null === (a = this.offset) || void 0 === a ? void 0 : a.y) && void 0 !== r ? r : 0) } } getPointByIndex(t) { if (!this.raw || !this.raw.length) throw new Error(C.noPolygonDataLoaded); const e = this.raw[t % this.raw.length]; return { x: e.x, y: e.y } } createPath2D() { var t, e; const i = this.options; if (this.path2DSupported && (null === (t = this.paths) || void 0 === t ? void 0 : t.length)) for (const t of this.paths) { const o = null === (e = t.element) || void 0 === e ? void 0 : e.getAttribute("d"); if (o) { const e = new Path2D(o), n = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix(), s = new Path2D, a = n.scale(i.scale); s.addPath ? (s.addPath(e, a), t.path2d = s) : delete t.path2d } else delete t.path2d; !t.path2d && this.raw && (t.path2d = new Path2D, t.path2d.moveTo(this.raw[0].x, this.raw[0].y), this.raw.forEach((e, i) => { var o; i > 0 && (null === (o = t.path2d) || void 0 === o || o.lineTo(e.x, e.y)) }), t.path2d.closePath()) } } initRawData(t) { return Ei(this, void 0, void 0, function* () { const e = this.options; if (e.url) this.raw = yield this.downloadSvgPath(e.url, t); else if (e.data) { const i = e.data; let o; if ("string" != typeof i) { const t = i.path instanceof Array ? i.path.map(t => `<path d="${t}" />`).join("") : `<path d="${i.path}" />`; o = `<svg ${'xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"'} width="${i.size.width}" height="${i.size.height}">${t}</svg>` } else o = i; this.raw = this.parseSvgPath(o, t) } this.createPath2D() }) } } const zi = new class { constructor() { this.id = "polygonMask" } getPlugin(t) { return new Ii(t) } needsPlugin(t) { var e, i, o; return null !== (i = null === (e = null == t ? void 0 : t.polygon) || void 0 === e ? void 0 : e.enable) && void 0 !== i ? i : void 0 !== (null === (o = null == t ? void 0 : t.polygon) || void 0 === o ? void 0 : o.type) && t.polygon.type !== Ai.none } loadOptions(t, e) { if (!this.needsPlugin(e)) return; const i = t; let o = i.polygon; void 0 === (null == o ? void 0 : o.load) && (i.polygon = o = new Oi), o.load(null == e ? void 0 : e.polygon) } }; class Hi extends ri { constructor() { super(), this.addPlugin(ui), this.addPlugin(Pi), this.addPlugin(zi) } } const Di = new Hi; Di.init(); const { particlesJS: Fi, pJSDom: Ni } = (t => { const e = (e, i) => t.load(e, i); return e.load = ((e, i, o) => { t.loadJSON(e, i).then(t => { t && o(t) }) }), e.setOnClickHandler = (e => { t.setOnClickHandler(e) }), { particlesJS: e, pJSDom: t.dom() } })(Di); return e })() }), t(".premium-particles-yes").length) && ("undefined" != typeof elementorFrontend && elementorFrontend.isEditMode() ? e(window.current_scope) : window.scopes_array && Object.values(window.scopes_array).forEach(function (t) { e(t) })); function e(t) { var e, i, o, n, s, a = t, r = a.data("id"), c = {}; if (!(c = elementorFrontend.isEditMode() ? (i = a.find("#premium-particles-" + r), o = i.data("particles-style"), n = i.data("particles-zindex"), s = i.data("particles-devices"), !!o && (c.zindex = n, c.style = o, c.devices = s.split(" "), 0 !== Object.keys(c).length ? c : void 0)) : !!(e = a.data()).particlesStyle && (c.zindex = e.particlesZindex, c.style = e.particlesStyle, c.devices = e.particlesDevices.split(" "), 0 !== Object.keys(c).length ? c : void 0))) return !1; var l = elementorFrontend.getCurrentDeviceMode(); -1 !== c.devices.indexOf(l) && (a.attr("id", "premium-section-particles-" + r), tsParticles.load("premium-section-particles-" + r, c.style), a.children("canvas.tsparticles-canvas-el").css({ zIndex: c.zindex })) } }(jQuery);